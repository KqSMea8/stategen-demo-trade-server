 [
        {
            "id": "5bd4772a14e994202cd5bdb7",
            "author_id": "504c28a2e2b845157708cb61",
            "tab": "share",
            "content": "2018年10月27日晚上，突然收到服务器不能访问的告警通知，拜托了狼叔 @i5ting 帮忙看看，结果登不上也ping不通。\r\n后来收到短信，发现是被ucloud封了，短信内容如下：\r\n\r\n> 【UCloud】尊敬的UCloud用户，您的IP：123.59.77.142  存在URL ：https://cnodejs.org/topic/57239bce5a26c4a841ecbf01 （详细信息请查看邮箱）包含违禁内容（包括但不限于翻墙等），违反了国家有关法律法规。目前依主管单位要求，对您的IP予以封停，请您尽快处理违规内容。待处理完成后请联系技术支持重新开启业务。[4000188113]\r\n\r\n然后联系了ucloud的客服，一下就打通了，对方态度挺好处理问题也快。ucloud说是运营商那边封的，不是他们的检测机制。所以需要联系运营商解决。\r\n考虑到各位亲爱的网友们的行为我无法控制，那么一直跟越来越严格的审查系统对抗只会让自己疲惫，所以我就站点迁到国外。来到了aws jp。\r\n\r\n我大致测了测，电信和移动的访问速度非常快，100ms以内，联通会慢一点，400ms以内吧。\r\n\r\n建议翻墙访问。",
            "title": "服务器迁移至 aws 日本机房",
            "last_reply_at": "2018-11-09T15:04:17.979Z",
            "good": false,
            "top": true,
            "reply_count": 56,
            "visit_count": 4322,
            "create_at": "2018-10-27T14:33:14.694Z",
            "author": {
                "loginname": "alsotang",
                "avatar_url": "https://avatars1.githubusercontent.com/u/1147375?v=4&s=120"
            }
        },
        {
            "id": "5ba5fd6237a6965f59051bd1",
            "author_id": "4f447c2f0a8abae26e01b27d",
            "tab": "share",
            "content": "> 『大吉大利，明早吃蛋。』\r\n> \r\n> 底部有文化衫活动邀您参加。\r\n\r\n知乎原文地址：https://zhuanlan.zhihu.com/p/45143762\r\n\r\n![image.png](//static.cnodejs.org/FkV4SW_6zuURqOdHc0lalW7pC7Fv)\r\n\r\n2016 年 9 月，我们在 JSConf China 2016 上宣布了 Egg 开源，至今整整 2 年了。\r\n在 [Egg 2.0 发布通告](https://zhuanlan.zhihu.com/p/31640541) 提到，核心代码已经很稳定，__后续重心主要在开发者体验方面的优化。__\r\n\r\n> Egg 是阿里 Node.js 的核心基础框架，面向『企业级的 Web 基础框架』这个领域，提供了「微内核 + 插件机制 + 框架定制能力」，完美达成生态共建和差异化定制的平衡点。\r\n> \r\n> 既适合个人小项目快速开发，也适合团队架构师基于自身的技术架构在 Egg 基础上扩展出适合特定团队业务场景的框架。\r\n> \r\n> 它沉淀自阿里在各行各业不同领域的大规模工程实践经验，稳定支撑了多年天猫双11大促，顶级流量压力。\r\n\r\n\r\n接下来跟大家分享下，过去 9 个月里面，我们的一些产出和数据，本文较长，请慢慢品用：\r\n\r\n* __开发者数据分享__\r\n* __文化衫活动邀请__\r\n* __开发者体验优化__\r\n    * TypeScript 的支持\r\n    * 新增「生命周期」\r\n    * Alinode 接入指南\r\n    * 和 Java 的互联互通方案\r\n    * 实践案例 - 用 Egg 重构的 cnode 社区\r\n    * 来自语雀团队的 sequelize ORM 实践分享\r\n    * 与 Webpack 等前端工程的实践分享\r\n    * 错误处理和 opentracing 的 RFC\r\n    * egg-init 骨架重构方案\r\n* __未来规划__\r\n\r\n\r\n---\r\n\r\n## 开发者数据\r\n\r\n\r\n![image.png | left | 600x303](https://cdn.nlark.com/yuque/0/2018/png/84182/1537602757084-21ffa6c7-d95d-4da0-b48b-6312551d1b03.png \"\")\r\n\r\n\r\n* 官网 PV 在 1.2w 左右。\r\n* npm egg 模块数 1006 个，GitHub 依赖库 3738 个。\r\n* 一千多个 Pull Request，2200 个 Issue，130 多位 Contributors 。\r\n* 共发布了 81 个版本，[Release Note](https://github.com/eggjs/egg/releases) 。\r\n* 社区实践项目：[cnodejs/egg-cnode](https://github.com/cnodejs/egg-cnode) ，[eggjs/awesome-egg](https://github.com/eggjs/awesome-egg) 。\r\n* [知乎专栏 Node.js](https://zhuanlan.zhihu.com/eggjs) 一共发布了 48 篇文章，7600 订阅，阅读数据未知（知乎创作者中心看不上咱，不给内测资格 😭）。\r\n\r\n__正在使用 Egg 的公司，不完全统计：__\r\n\r\n* 深度使用的： 阿里巴巴，全民直播，网易考拉\r\n* 使用并有分享过使用经验的：去哪儿，摩拜，点评\r\n* 有个别团队咨询过试水但最终有没有落地的不知道：美团，新浪，百度，腾讯，YY 等\r\n\r\n__顺便分享一个 cnpm 的__[统计数据](https://fengmk2.com/npm-china-mirror-downloads?year=2018)__：__\r\n\r\n\r\n\r\n![image.png | left | 720x423](https://cdn.nlark.com/yuque/0/2018/png/84182/1537602856784-1517e844-15e1-495f-b58b-c5103a09b5a3.png \"\")\r\n\r\n\r\n\r\n\r\n![image.png | left | 720x413](https://cdn.nlark.com/yuque/0/2018/png/84182/1537602864083-a887fcab-8754-4ba6-90cb-eada7a3a477f.png \"\")\r\n\r\n\r\n\r\n---\r\n\r\n## 文化衫活动\r\n\r\n欢迎大家访问以下链接，分享你们的实践经验，有机会获得 Egg 文化衫和相关周边喔~\r\n另外，第 10000 Star 的同学 [godmeir](https://github.com/zhyjor) 请联系我们。\r\n\r\n[『2018 年 EggJS 怎么样了？对它的看法有什么变化？』](https://www.zhihu.com/question/273783655)\r\n\r\n\r\n\r\n\r\n![image.png | left | 600x800](https://cdn.nlark.com/yuque/0/2018/png/84182/1537602940849-da573bac-6899-47c1-ae18-e288e6d6fe79.png \"\")\r\n\r\n\r\n\r\n---\r\n\r\n## 开发者体验优化\r\n\r\n接下来跟大家分享下这段时间来，我们在『开发者体验』方面做的一些优化。\r\n\r\n### TypeScript\r\n\r\n这几年来 TypeScript 很受欢迎，它的静态类型检查，智能提示，IDE 友好性等特性，对于大规模企业级应用，是非常的有价值的，被视为是企业级 JS 开发的未来之一。\r\n\r\n阿里内部实践 TS 也蛮久了，在 5 个月前，也把我们的其中一部分成熟的实践，分享出来：\r\n[『天猪：当 Egg 遇到 TypeScript，收获茶叶蛋一枚』](https://zhuanlan.zhihu.com/p/35334932)\r\n\r\n\r\n非常感谢 @吖猩 在这领域的持续贡献：\r\n* [ts-node 下错误堆栈问题排查小记](https://zhuanlan.zhihu.com/p/43181384)\r\n* [Egg TS 改造总结](https://github.com/whxaxes/blog/issues/12)\r\n* [Typescript 在 Egg + Vue 应用中的实践](https://github.com/whxaxes/blog/issues/11) \r\n\r\n这块目前还在持续优化中，有兴趣的同学可以参与以下几项优化：\r\n\r\n* egg-ts-helper 增加对 js 的支持，这样非 ts 的同学，也能享受到智能提示和静态检查的 Buffer 加成。\r\n* 完善插件自带的 d.ts 方便其他开发者。\r\n* 分享你的上层封装，如通过装饰器来注册路由或 AOP。（内部有不少实践，但还未达成共识）\r\n\r\n> PS： Egg.js 本身不会使用 TypeScript 重写，对于框架本身而言，JS 的灵活性可以让它更容易实现一些特性，同时它也并没有那么复杂的业务逻辑，TypeScript 并无法给框架研发带来更多的帮助。\r\n\r\n### 生命周期\r\n\r\n之前 Egg 提供给开发者在启动期的钩子不多，只有 beforeStart 几个。\r\n感谢 killagu 同学给我们补充了更细致的生命周期，相关的 RFC 和文档如下：\r\n\r\n* [[RFC] egg-core 增加应用启动阶段 · Issue #2520 ](https://github.com/eggjs/egg/issues/2520#issuecomment-399008659)\r\n* [Egg 文档 - 生命周期](https://eggjs.app/zh-cn/advanced/loader.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F)  （目前文档还有较大的优化空间，我们将在后续继续完善。）\r\n\r\n```javascript\r\n// app.js\r\nclass AppBootHook {\r\n  configDidLoad() {\r\n    // Config, Plugin files have did load.\r\n  }\r\n\r\n  async didLoad() {\r\n    // All files have did load, start plugin here.\r\n  }\r\n\r\n  async willReady() {\r\n    // All plugins have started, can do some thing before app ready.\r\n  }\r\n\r\n  async didReady() {\r\n    // Worker is ready, can do some things don't need to block the app boot.\r\n  }\r\n\r\n  async serverDidReady() {\r\n    // Server is listening.\r\n  }\r\n\r\n  async beforeClose() {\r\n    // Do some thing before app close.\r\n  }\r\n}\r\n```\r\n\r\n\r\n### Alinode\r\n\r\nNode 发展到今天，已经被越来越广泛地应用到前后端分离、全栈开发、客户端工具等领域。\r\n然而，相对于应用层的蓬勃发展，其 Runtime 对于绝大部分前端出身的开发者来说，处于黑盒的状态，这一点并没有得到很好的改善，从而也阻碍了 Node.js 在业务中的应用和推广。\r\n\r\n作为一个 Node 开发者，最头痛的事莫过于莫名其妙的 CPU 100% 和内存泄露导致的 OOM。\r\n\r\n所幸的是，阿里云 @朴灵 团队的 [Node.js 性能平台](https://www.aliyun.com/product/nodejs) 为 Node 开发者提供了：`性能监控、安全提醒、故障排查、性能优化` 等服务的整体性解决方案，提供完善的工具链和服务，协助开发者快速发现和定位线上问题。这些年来，为我们解决了非常多的线上问题，为业务保驾护航。\r\n\r\n相关分享：\r\n* [Node 案发现场揭秘 —— Coredump 还原线上异常](https://zhuanlan.zhihu.com/p/41178823)\r\n* [一行 delete require.cache 引发的内存泄漏血案](https://zhuanlan.zhihu.com/p/34702356)\r\n* [Egg 文档 - Alinode 一键接入](https://eggjs.app/zh-cn/core/deployment.html#nodejs-%E6%80%A7%E8%83%BD%E5%B9%B3%E5%8F%B0alinode)\r\n\r\n当然，在日常的答疑中，很多同学也表达了对数据安全方面的担忧。从我个人的角度来看，Alinode 的采集脚本，都是开源了，不会采集隐私数据。实在不行，在压测期接入用用也行，绝对可以让我们少掉一点头发，良心推荐。\r\n\r\n### 和 Java 互联互通的方案\r\n\r\nNode.js 在蚂蚁和阿里已经发展了四、五年时间，从最开始「前端工程师的玩具」，到 Web、BFF 场景的破局，逐步走到线上甚至是一些核心业务，非常不容易。\r\n\r\n回头想想 Nodejs 为什么能活下来？依靠的绝不仅仅是：非阻塞I/O、事件驱动、轻量这些官方宣传的特性，__我们认为更重要一点是我们打通了和 Java 的桥梁，实现了互联互通，这才让它真正融入阿里的技术体系。__\r\n\r\n伴随 [蚂蚁 SOFA Java 技术栈](https://www.cloud.alipay.com/products/SOFA) 的开源，我们也开源了 Nodejs RPC 相关模块，希望能填补 Nodejs 社区这块的空白，也将我们几年来在 Nodejs 基础技术的一些经验做个总结和分享。\r\n\r\n推荐阅读小丸子姐姐的相关科普文章：\r\n\r\n* [Eggjs 和 SOFA 的跨语言互调](https://zhuanlan.zhihu.com/p/38004479)\r\n* [聊聊 Node.js RPC（一）— 协议](https://zhuanlan.zhihu.com/p/38012481)\r\n* [聊聊 Node.js RPC（二）— 服务发现](https://zhuanlan.zhihu.com/p/40606909)\r\n\r\n### egg-cnode\r\n\r\n朴老师发起的 [cnodejs/egg-cnode](https://github.com/cnodejs/egg-cnode) 项目，用 Egg 重写了 cnode 社区应用。\r\n目前完成了功能层面的重构以及测试用例的补全：\r\n\r\n* 文件数减少 41，减少 22%\r\n* 代码行数减少 2460 行，减少 4.7%\r\n* 测试代码减少 980 行，减少 39%，覆盖率高于原项目。\r\n\r\n目前还有较大的优化空间，因为第一阶段专注于功能迁移，不做大的优化，有些使用方式不符合 Egg 的最佳实践，欢迎有兴趣的同学加入一起完善。\r\n\r\n### 值得关注的 RFC 和分享\r\n\r\n> 在 eggjs 团队的日常协作中，遵循「基于 GitLab 的硬盘式异步协作模式」。\r\n> 通过 [issue](https://github.com/eggjs/egg/issues) 发起 RFC 提案 -> 讨论定稿-> 提交 Pull Request -> Code Review -> 发布。\r\n> 这样便于沉淀，即使是当时没有参与讨论的开发者，事后也能通过 issue 了解某个功能设计的前因后果。\r\n\r\n__Θ 来自 __[语雀团队](https://www.yuque.com/)__ 的 ORM 实践分享__\r\n* 语雀是基于 Egg 技术栈研发的，算是为数不多的涉及到各个技术点的 Node 大应用。\r\n* [Egg 文档 - Sequelize](https://eggjs.app/zh-cn/tutorials/sequelize.html)\r\n\r\n__Θ 与 Webpack 等前端工程的实践分享__\r\n\r\n* [Egg 文档 - Assets 静态资源](https://eggjs.app/zh-cn/tutorials/assets.html)\r\n* 来自 [easywebpack](https://zhuanlan.zhihu.com/easywebpack) 的实践\r\n* 上层同构框架：[alibaba/beidou](https://github.com/alibaba/beidou) 和 [Serlina](https://zhuanlan.zhihu.com/p/41947819)\r\n\r\n__Θ 错误处理 && 问题跟踪__\r\n\r\n* [[RFC] egg-opentracing · Issue #39](https://github.com/eggjs/egg/issues/39)\r\n* [[RFC] 应用自定义 4xx 和 5xx 的方案 · Issue #1086](https://github.com/eggjs/egg/issues/1086)\r\n* [[RFC] 统计 egg 加载过程的各步骤的耗时 · Issue #1898](https://github.com/eggjs/egg/issues/1898#issuecomment-386823829)\r\n* [handle unconsume multipart request data in egg itself. · Issue #2897](https://github.com/eggjs/egg/issues/2897)\r\n\r\n__Θ 工具优化__\r\n目前的 egg-init 存在以下问题：\r\n\r\n* 脚手架逻辑集中化，全部在 egg-init 本身，作为全局命令，更新不方便。\r\n* 模板无法定制自己的逻辑，无法代码共享。\r\n* 没有 sub generator，如 egg-init add controller Test 这样的功能。\r\n* 脚手架只在项目初始化时用到，无法支撑升级功能，容易腐化和分裂。\r\n* 上层封装不方便，不支持 preset 。\r\n\r\n因此提出了 『[[RFC] egg-init refactor ](https://github.com/eggjs/egg/issues/2892)』，应该下个月可以完工并分享给大家。\r\n\r\n__Θ 科普文__\r\n提到 Egg 值得自豪的应该是我们的文档吧，我们深知前端开发者在后端知识面还有很多需要科普的，也很乐意分享我们的实践：\r\n\r\n[『专访死马：为什么说Egg.js是企业级Node框架』](https://zhuanlan.zhihu.com/p/36240171)\r\n\r\n\r\n* [科普文：运维不给升级 Node 版本怎么办？](https://zhuanlan.zhihu.com/p/39226941)\r\n* [科普文：为什么不能在服务器上 npm install ？](http://zhuanlan.zhihu.com/p/39209596)\r\n* [聊聊 Node.js RPC（一）— 协议](https://zhuanlan.zhihu.com/p/38012481)\r\n* [聊聊 Node.js RPC（二）— 服务发现](https://zhuanlan.zhihu.com/p/40606909)\r\n\r\n## 未来规划\r\n\r\n老实说没有太多新特性，还是那个原因：__Egg 采用的是『微内核 + 插件 + 上层框架』模式。__\r\n\r\nEgg 自身的迭代采取插件化的开发机制，功能分散在不同的模块中，可能开发者在使用时感知不到它的版本变更，但其实它一直都在进化。每周都可能有新特性和 BugFix 发布，更像是一个『改良派』而不是『改革派』，它会在兼容的前提下不断进化。\r\n\r\n接下来的规划，还将继续放在 __『开发者体验优化 + 实践经验分享』__ 方面。\r\n\r\n* egg cli 工具链和骨架的重构优化。\r\n* TypeScript 的继续优化，以及增加对 js 项目智能提示方面的支持。\r\n* 更多的实践项目和科普分享。\r\n* 国际化。\r\n\r\n仅凭我们自己的精力是远远不够的，欢迎社区的大家一起加入，共同推动 Node 的发展。\r\n\r\n## 写在最后\r\n\r\n* 如果你喜欢 Egg，请支持我们：\r\n* 分享本文，为我们点赞。\r\n* 来分享下你们的实践，无论大小，这很重要，谢谢，将有机会获得我们的文化衫。\r\n    \r\n[『2018 年 EggJS 怎么样了？对它的看法有什么变化？』](https://www.zhihu.com/question/273783655)\r\n\r\n\r\n* 如果喜欢我的文章，请关注 [我的知乎](https://www.zhihu.com/question/273783655) 和 [Follow GitHub](https://www.zhihu.com/question/273783655) 。\r\n* 广州阿里游戏，招前端，熟悉动效，Node 的速来~",
            "title": "EggJS 10000 Star + 2 years - 阿里 Node 企业级框架 ✨✨✨",
            "last_reply_at": "2018-11-08T04:10:56.714Z",
            "good": true,
            "top": true,
            "reply_count": 53,
            "visit_count": 9769,
            "create_at": "2018-09-22T08:29:22.948Z",
            "author": {
                "loginname": "atian25",
                "avatar_url": "https://avatars2.githubusercontent.com/u/227713?v=4&s=120"
            }
        },
        {
            "id": "5baee8de9545eaf107b9c6f3",
            "author_id": "51f0f267f4963ade0e08f503",
            "tab": "share",
            "content": "# Node.js 新生态\r\n\r\n关于 SSR、IoT、应用治理，以及来自腾讯的新物种 —— Tars.js，\r\n\r\n腾讯、ThoughtWorks、阿里巴巴的 4 位分享者，期待和你交流碰撞层出不穷的 Node.js 新应用场景。\r\n\r\n## Agenda\r\n\r\n![20180929110352.png](//static.cnodejs.org/FmVpEKuYsrXt8ek9z8d6DjFexMAc)\r\n\r\n时间：2018.10.13\r\n地点：深圳后海阿里中心\r\n报名链接: [https://survey.alibaba.com/survey/AgD9rVfQT](https://survey.alibaba.com/survey/AgD9rVfQT)\r\n活动主页: [http://nodejs.club/](http://nodejs.club/)\r\n\r\n注意: 沙龙场地有限，在报名链接中仔细填写「关注Node.js 新生态中的哪些具体问题」对最终挑选参加资格会有帮助。",
            "title": "Node 地下铁第七期「深圳站」线下沙龙邀约 - Node.js 新生态",
            "last_reply_at": "2018-11-01T12:53:15.077Z",
            "good": false,
            "top": true,
            "reply_count": 25,
            "visit_count": 5027,
            "create_at": "2018-09-29T02:52:14.701Z",
            "author": {
                "loginname": "lellansin",
                "avatar_url": "https://avatars2.githubusercontent.com/u/2081487?v=4&s=120"
            }
        },
        {
            "id": "5b911f1837b3005a0b0e6c16",
            "author_id": "55500f555809a4b66f37f625",
            "tab": "share",
            "content": "## 活动说明\r\n\r\n### 本次活动由蚂蚁金服-国际事业群-前端团队承办。\r\n\r\n> * 时间：2018 年 9 月 23 日 14:00 - 18:00\r\n> * 地点：浙大玉泉校区邵逸夫科学馆 117 会堂\r\n> * 报名链接：[https://www.bagevent.com/event/1843696](https://www.bagevent.com/event/1843696)\r\n> \r\n\r\n---\r\n\r\n\r\n## 活动的主题如下（包括PPT）：\r\n\r\n### 《DataHub2 - 你的最后一个 mock 方案》\r\nPPT：[download: DataHub.pdf](https://www.yuque.com/attachments/yuque/0/2018/pdf/95383/1537925050307-1fa501d9-b3fd-44c7-953b-8291d2c86ea8.pdf \"size:5046844\")\r\n\r\n分享时间：14:00 - 14:40\r\n\r\n主讲人介绍：张宇恒([@zhangyuheng](https://github.com/zhangyuheng)) - 蚂蚁国际高级前端工程师，[DataHub](https://github.com/macacajs/macaca-datahub) 核心开发，格言：To Be A Better Hacker 。\r\n\r\n\r\n\r\n![1536220954455-08024e18-182c-4e9c-8534-99ca63d0dd4b.png | left](//static.cnodejs.org/FuvmcnVJIRbF-xqcrJDFfiag0bSi \"\")\r\n\r\n\r\n内容：DataHub 是为解决复杂业务场景而诞生，但同时能够渐进式退化，为项目研发提供通用的 mock 解决方案。舒适的 Web 研发体验，从研发、测试、联调阶段贯穿始终的数据提供能力，剖析如何设计一个 mock 平台的核心理念和实践范式。从开发瓶颈和服务演进的角度讲述「__最后一个__」mock 方案。\r\n\r\n### 《蚂蚁国际前端工程体系》\r\n\r\n分享时间：14:50 - 15:30\r\n\r\n主讲人介绍：徐达峰([@xudafeng](https://github.com/xudafeng)) - 蚂蚁金服前端技术专家，阿里开源测试框架 [Macaca](https://github.com/alibaba/macaca) 作者，[autoresponsive-react](https://github.com/xudafeng/autoresponsive-react) 作者。\r\n\r\n\r\n\r\n![1536221094365-b2da0ffa-9103-478b-bd39-c8de3f06a0f2.png | left](//static.cnodejs.org/FgCUNY56nLYcXl7pXP1zaCIKNmOJ \"\")\r\n\r\n内容：介绍蚂蚁金服国际部门在国际化与本土化进程中遇到的挑战和成长。剖析中国技术出海的特点和如何快速构建合适的前端工程体系，也包括工具体系、持续交付、自动化测试等几个方向上的实践和思考。同时也会涉及 Macaca 技术生态的国际化成长。\r\n\r\n### 《Node.js 微服务实践》\r\nPPT：[download: Node.js 微服务实践.pdf](https://www.yuque.com/attachments/yuque/0/2018/pdf/95383/1537925145070-a192b890-1cbb-47da-bd4d-842671ceac98.pdf \"size:5178626\")\r\n\r\n分享时间：15:40 - 16:20\r\n\r\n主讲人介绍：高晓晨([@gxcsoccer](https://github.com/gxcsoccer)) - 蚂蚁金服前端技术专家，企业级 Web 框架应用框架 [Egg.js](https://github.com/eggjs) 核心成员，[sofa-rpc-node](https://github.com/alipay/sofa-rpc-node) 作者。\r\n\r\n\r\n\r\n![1536222500407-c710cca5-36d4-4685-a9d2-ba34163c39ff.png | left](//static.cnodejs.org/Fk0AYqZmVT5QmcnpFKO8AKCGjM-l \"\")\r\n\r\n内容：介绍金服如何用 Node.js 来实现微服务，包括 RPC 原理、服务发现、负载均衡等话题。同时会介绍一下如何使用和扩展我们开源的 [sofa-rpc-node](https://github.com/alipay/sofa-rpc-node) 项目来帮助外部实现 RPC，为系统架构带来新活力。\r\n\r\n### 《GraphQL 生态介绍》\r\n\r\nPPT：[download: GraphQL.pdf](https://www.yuque.com/attachments/yuque/0/2018/pdf/95383/1537925158919-2cd3bd39-31bd-4377-b347-33213489cde2.pdf \"size:4043353\")\r\n\r\n分享时间：16:30 - 17:10\r\n\r\n主讲人介绍：张开宇([@zhangkaiyulw](https://github.com/zhangkaiyulw)) - 前 Oracle 北京，香港 Beecrazy 员工。Ruby on Rails 贡献者之一。在后端，前端，移动端，以及 React Native 开发上，有丰富的经验。曾尝试将 iOS 系统的 Cocoa Touch API 风格移植到 HTML 网页中，并开发了基于其的一款国际象棋应用。有丰富大量的开源代码。\r\n\r\n\r\n\r\n![1536220909272-71b9e8f9-1665-4b84-85a0-26d686b8a7c5.png | left](//static.cnodejs.org/Fln08dUMEWfnEFwd4gmpC8QJJP9O \"\")\r\n\r\n\r\n内容：本次演讲介绍实现GraphQL API的工具，包括 apollo-server、merge-graphql-schemas、graphql-middleware、amur 脚手架工具以及他们的用法。并五分钟内演示带有上传功能，混合字段类型的，带有数据关联的复杂系统的 API。\r\n\r\n### 《 Megalo - 考拉的小程序解决方案》\r\n\r\nPPT：[download: megalo-考拉的小程序解决方案.pdf](https://www.yuque.com/attachments/yuque/0/2018/pdf/95383/1537925172399-4ed1c6cc-479e-4e4a-b537-0b4353da8198.pdf \"size:1943122\")\r\n\r\n分享时间：17:20 - 18:00\r\n\r\n主讲人介绍：网易考拉前端工程师，吴子然[@elcarim](https://github.com/elcarim5efil)，[mpregular](https://github.com/kaola-fed/mpregular)、[megalo](https://github.com/kaola-fed/megalo) 核心开发。\r\n\r\n\r\n\r\n![网易考拉_吴子然.jpeg | left](//static.cnodejs.org/Fh_VjuoZMUe_g5Tof53qU1iZ-wh_ \"\")\r\n\r\n内容：介绍考拉的小程序框架发展历程，我们是如何在现有框架上做改造，在小程序上支持更多的 Vue 特性，让跨端开发变得更简单。\r\n\r\n\r\n---\r\n\r\n\r\n## 现场照片\r\n\r\n\r\n\r\n![image.png | left | 827x272](https://cdn.nlark.com/yuque/0/2018/png/95383/1537924550598-bf24d186-3ff1-494d-a4f2-3702fac3aa6a.png \"\")\r\n\r\n\r\n\r\n\r\n![image.png | left | 827x257](https://cdn.nlark.com/yuque/0/2018/png/95383/1537924563365-f723e300-5223-4fc4-8751-416c98b9afd3.png \"\")\r\n\r\n\r\n\r\n\r\n![image.png | left | 827x620](https://cdn.nlark.com/yuque/0/2018/png/95383/1537924608159-042af9f1-0880-4003-a3ec-2697cf38bf18.png \"\")\r\n\r\n\r\n\r\n\r\n![image.png | left | 827x620](https://cdn.nlark.com/yuque/0/2018/png/95383/1537924578426-21656c2f-8b66-4452-915d-51b3320fbabb.png \"\")\r\n\r\n\r\n\r\n\r\n![image.png | left | 827x620](https://cdn.nlark.com/yuque/0/2018/png/95383/1537924629304-e8547f9d-2bed-4b1c-bf50-cfbdd52f9d8e.png \"\")\r\n\r\n\r\n\r\n\r\n![image.png | left | 827x602](https://cdn.nlark.com/yuque/0/2018/png/95383/1537926665393-17bb8bbb-d585-4bc9-a7cc-80cad0d6596f.png \"\")\r\n\r\n\r\n\r\n\r\n![image.png | left | 827x620](https://cdn.nlark.com/yuque/0/2018/png/95383/1537924638476-713a60a3-43d9-4261-9f2e-672e4cf4487d.png \"\")\r\n\r\n\r\n\r\n\r\n![image.png | left | 827x615](https://cdn.nlark.com/yuque/0/2018/png/95383/1537924701018-cd3800f5-3940-4877-844c-29b7f1015e37.png \"\")\r\n\r\n\r\n\r\n\r\n![image.png | left | 827x606](https://cdn.nlark.com/yuque/0/2018/png/95383/1537926870402-15f18f5d-dbe9-4faf-a1b6-301e7fe5fe67.png \"\")\r\n\r\n\r\n\r\n\r\n\r\n![image.png | left | 827x604](https://cdn.nlark.com/yuque/0/2018/png/95383/1537926843721-002a0b79-235d-456e-8daf-5f3fde47b5b0.png \"\")\r\n\r\n\r\n\r\n\r\n\r\n\r\n![image.png | left | 827x607](https://cdn.nlark.com/yuque/0/2018/png/95383/1537925309980-a2262bf0-d3e6-4152-8150-1c8487cfda69.png \"\")\r\n\r\n\r\n### 特别感谢浙大软件学院对本次活动提供场地支持！\r\n\r\n\r\n---\r\n\r\n\r\n## 关于 NodeParty\r\n\r\n\r\n\r\n![image | center](https://cdn.nlark.com/yuque/0/2018/png/95383/1536228236464-a496d8a0-4862-4946-af56-b55fb7c68af3.png \"\")\r\n\r\n\r\nNodeParty 品牌诞生于 CNode 社区，杭州 NodeParty 是由大搜车（Souche Inc.）发起的一个面向 Node.js 爱好者的技术分享聚会，希望能够构建一个持续的分享学习的平台，一起发展 Node.js 生态。",
            "title": "第七期杭州 Node Party 回顾【附PPT】",
            "last_reply_at": "2018-10-17T07:50:19.775Z",
            "good": false,
            "top": true,
            "reply_count": 60,
            "visit_count": 10013,
            "create_at": "2018-09-06T12:35:36.197Z",
            "author": {
                "loginname": "yllziv",
                "avatar_url": "https://avatars1.githubusercontent.com/u/11460601?v=4&s=120"
            }
        },
        {
            "id": "5be95c612fed25406c25dcd1",
            "author_id": "50b5bc5d637ffa4155091236",
            "tab": "ask",
            "content": "![thinkjs.png](//static.cnodejs.org/FpS1syKONltijruBG5ngnhYerKbb)",
            "title": "有人跑过express 和thinkjs的benchmark吗？",
            "last_reply_at": "2018-11-12T13:46:38.585Z",
            "good": false,
            "top": false,
            "reply_count": 1,
            "visit_count": 41,
            "create_at": "2018-11-12T10:56:33.105Z",
            "author": {
                "loginname": "yakczh",
                "avatar_url": "https://avatars3.githubusercontent.com/u/6591466?v=4&s=120"
            }
        },
        {
            "id": "5be961d72fed25406c25dcee",
            "author_id": "536af53d9968d761330390f7",
            "tab": "share",
            "content": "### [老用户享优惠](https://promotion.aliyun.com/ntms/act/kuanghuanjie.html)\r\n### [个人建站](https://promotion.aliyun.com/ntms/act/qwbk.html)\r\n### [企业级高性能](https://promotion.aliyun.com/ntms/act/enterprise-discount.html)\r\n### [短信接入](https://promotion.aliyun.com/ntms/act/alicomcloud20181111.html)\r\n### [结合代金券](https://dwz.cn/)\r\n### [叠加购物车](https://promotion.aliyun.com/ntms/act/shoppingcart.html)\r\n另外叠加购物车满1000减50的优惠，满2000减100，以此类推，价格比某某 云还便宜...",
            "title": "阿里云老用户享优惠",
            "last_reply_at": "2018-11-12T11:19:51.942Z",
            "good": false,
            "top": false,
            "reply_count": 0,
            "visit_count": 40,
            "create_at": "2018-11-12T11:19:51.942Z",
            "author": {
                "loginname": "skythinking",
                "avatar_url": "https://avatars3.githubusercontent.com/u/7401507?v=4&s=120"
            }
        },
        {
            "id": "5be432ea646a05745b7b9e5c",
            "author_id": "5a3b17649807389a1809f5a5",
            "tab": "ask",
            "content": "数据库数据\r\n[ { _id: 5be42b9e49a17f3270d8d9a5, url: '/test/*/test', __v: 0 },\r\n  { _id: 5be42e9a5330e01e64ae6029, url: '/test/%/test', __v: 0 } ]\r\n********\r\n用mongo怎样匹配类似“/test/123455/test”这样的值呢",
            "title": "mongo设计基于resful风格的权限控制，url匹配问题",
            "last_reply_at": "2018-11-12T10:53:13.507Z",
            "good": false,
            "top": false,
            "reply_count": 6,
            "visit_count": 234,
            "create_at": "2018-11-08T12:58:18.371Z",
            "author": {
                "loginname": "Sxy97",
                "avatar_url": "https://avatars3.githubusercontent.com/u/24429847?v=4&s=120"
            }
        },
        {
            "id": "5bb3199aede204052db80345",
            "author_id": "5b9e04448f5b0c1c59ea0e80",
            "tab": "ask",
            "content": "如题，刚刚在论坛里面专门找了一下，最近的一次询问是三个月前的（[传送门](https://cnodejs.org/topic/5b2f02a757137f22415c4e90)此前帖子），真的好期待啊……",
            "title": "又3个月了，狼叔的《更了不起的Node.js》应该快出来了吧？",
            "last_reply_at": "2018-11-12T10:20:45.412Z",
            "good": false,
            "top": false,
            "reply_count": 24,
            "visit_count": 2345,
            "create_at": "2018-10-02T07:09:14.001Z",
            "author": {
                "loginname": "tufifth",
                "avatar_url": "https://avatars0.githubusercontent.com/u/34742669?v=4&s=120"
            }
        },
        {
            "id": "5be93cf0e161dc409d760d33",
            "author_id": "596437941b534b4408190c06",
            "tab": "ask",
            "content": "有使用nodejs开发过电信、移动或者联通的短信网关的吗？求实例。SMGP\\CMPP的都可以。",
            "title": "有使用nodejs开发过电信、移动或者联通的短信网关的吗？求实例。SMGP\\CMPP的都可以。",
            "last_reply_at": "2018-11-12T10:02:11.358Z",
            "good": false,
            "top": false,
            "reply_count": 1,
            "visit_count": 78,
            "create_at": "2018-11-12T08:42:24.499Z",
            "author": {
                "loginname": "tong3jie",
                "avatar_url": "https://avatars0.githubusercontent.com/u/14191774?v=4&s=120"
            }
        },
        {
            "id": "5b1e20e929e6e510415b29d0",
            "author_id": "5aed77ea1b02288048bd0cb6",
            "tab": "share",
            "content": "# 来自[github](https://github.com/shenzekun/useful-tools)\r\n\r\n# useful-tools\r\n> 🔨 一些有用的工具网站（**注意**：有些网站可能需要翻墙才能看到）\r\n\r\n## 浏览器兼容类🌎\r\n  \r\n  * [caniuse](https://caniuse.com/) （网站开发浏览器兼容性查询）\r\n  * [browserhacks](http://browserhacks.com/) (一些浏览器兼容写法)\r\n\r\n## 图片类😎\r\n  \r\n  * [Tinypng](https://tinypng.com/) （压缩图片）\r\n  * [标你妹啊](http://www.biaonimeia.com/login) (psd 标注)\r\n  * [Cool Backgrounds](https://coolbackgrounds.io/) （生成好看的渐变背景图）\r\n  * [carbon](https://carbon.now.sh/?bg=rgba(171,%20184,%20195,%201)&t=seti&wt=none&l=auto&ds=true&dsyoff=20px&dsblur=68px&wc=true&wa=true&pv=48px&ph=32px&ln=false&fm=Hack&fs=14px&si=false&es=2x&wm=false) (生成类似 mac 风格的代码图片，用于分享)  \r\n  * [Unsplash Source](https://source.unsplash.com/) (生成随机图片) \r\n  * [CSS Sprite Generator](https://spritegen.website-performance.org/) (生成雪碧图)\r\n  * [iconfont](http://www.iconfont.cn/plus) (阿里巴巴矢量图标库)\r\n  * [Preloaders](https://icons8.com/preloaders/) (加载图，**有些是收费的**)\r\n  * [desktoppr](https://www.desktoppr.co/wallpapers) （好看的壁纸）\r\n  * [Material icons](https://material.io/tools/icons/?style=baseline) (Material icons图标)\r\n\r\n ## 代码类⌨️\r\n  \r\n  * [Ubuntu pastebin](https://paste.ubuntu.com/) （代码分享）\r\n  * [Codepen](https://codepen.io/pens/) (在线代码编辑)\r\n  * [Jsbin](http://jsbin.com/) (在线代码编辑)\r\n  * [Ultimate CSS Gradient Generator](http://www.colorzilla.com/gradient-editor/) (生成 css 渐变)\r\n  * [Grabient](https://www.grabient.com/) (生成漂亮的 css 渐变)\r\n  * [Character Entity Reference Chart](https://dev.w3.org/html5/html-author/charref) (各种符号的转义字符)\r\n  * [缓动函数速查表](https://easings.net/zh-cn?tuyiyi.com)\r\n  * [Regexper](https://regexper.com/) (正则可视化)\r\n  * [Visualgo](https://visualgo.net/en) (数据结构，算法可视化)\r\n  * [Animista](http://animista.net/) (在线生成 css 动画)\r\n  * [PageSpeed Insights](https://developers.google.com/speed/pagespeed/insights/) (测试网站速度，优化性能)\r\n  * [Learn Git Branching](https://learngitbranching.js.org/) (以动画的形式让你学习 git)\r\n  * [Asciiflow](http://asciiflow.com/) (生成类似代码注释里那种佛祖的代码。。自己画😄)\r\n  * [PXtoEM](http://pxtoem.com/) (PX EM 单位换算)\r\n  * [Awehunt](https://awehunt.com/npmdownloads?ids=react,angular,vue,ember-cli) (npm包下载量曲线对比)\r\n\r\n## 效率类⚡️\r\n  \r\n  * [墨刀](https://modao.cc/) （画原型图）\r\n  * [石墨文档](https://shimo.im/) (多人实时协作的云端文档与表格)\r\n  * [resume-examples](https://www.hloom.com/resume-examples/) (简历模板)\r\n  * [Enhancv](https://enhancv.com/) (生成简历)\r\n  * [KOPPT](http://www.koppt.cn/index) (ppt 模板)\r\n  * [Canva](https://www.canva.com/templates/) (设计模板)\r\n  * [ProcessOn](https://www.processon.com/;jsessionid=EC0CB59BD105F6FD0294417AB0B0CC22.jvm1) (在线画流程图，思维导图、UI原型图等等)\r\n  * [WakaTime](https://wakatime.com/) (跟踪项目花费的时间，得装插件)\r\n  * [Screen Sizes](http://screensiz.es/) (移动屏幕尺寸)\r\n  * [Habitica](https://habitica.com/) (游戏化Todo)\r\n  * [Smallpdf](https://smallpdf.com/) (非常厉害的一个网站，PDF压缩，PDF转PPT，Word，Excel等等都可以直接通过这个页面实现)",
            "title": "分享一些有用的工具网站",
            "last_reply_at": "2018-11-12T09:38:43.503Z",
            "good": false,
            "top": false,
            "reply_count": 51,
            "visit_count": 5966,
            "create_at": "2018-06-11T07:12:41.157Z",
            "author": {
                "loginname": "shenzekun",
                "avatar_url": "https://avatars1.githubusercontent.com/u/21151080?v=4&s=120"
            }
        },
        {
            "id": "5be7939b21d75b74609f61c2",
            "author_id": "5ac77987e34737560fccaa7b",
            "tab": "share",
            "content": "前前后后花了5天的时间，因为想学习下rn，就把一些前置的知识学习了一遍\r\n\r\n在线预览：\r\n\r\nhttp://rode.bengbuzhangyue.xyz \r\n\r\n\r\n项目地址：\r\n\r\nhttps://github.com/BengBu-YueZhang/Rode",
            "title": "使用immutable.js和redux-saga, reselect 写的cnode社区",
            "last_reply_at": "2018-11-12T08:47:02.309Z",
            "good": false,
            "top": false,
            "reply_count": 2,
            "visit_count": 151,
            "create_at": "2018-11-11T02:27:39.898Z",
            "author": {
                "loginname": "BengBu-YueZhang",
                "avatar_url": "https://avatars3.githubusercontent.com/u/24958677?v=4&s=120"
            }
        },
        {
            "id": "5be7edb921d75b74609f62d7",
            "author_id": "5bc932c337a6965f59052399",
            "tab": "share",
            "content": "关于 egg-cluster 源码学习分享 [Egg 源码分析之 egg-cluster](https://zhuanlan.zhihu.com/p/49276061) ，还请大佬们多多指点",
            "title": "Egg 源码分析之 egg-cluster",
            "last_reply_at": "2018-11-12T06:55:27.218Z",
            "good": false,
            "top": false,
            "reply_count": 3,
            "visit_count": 199,
            "create_at": "2018-11-11T08:52:09.041Z",
            "author": {
                "loginname": "ZhangDianPeng",
                "avatar_url": "https://avatars1.githubusercontent.com/u/18463189?v=4&s=120"
            }
        },
        {
            "id": "5be29f7c21d75b74609f4fbf",
            "author_id": "5bda8a7793f8d64f74b012ae",
            "tab": "share",
            "content": "原文链接：https://www.jianshu.com/p/57e5bb1277ce\r\n\r\n# 前言\r\n**注意：上 HTTPS 超级简单，写这么多，只是因为过程比较有趣，就多哆嗦了几句**\r\n有了自己的博客：[《极简博客搭建，搭建超级简单又好看》](https://www.jianshu.com/p/527583637f17)\r\n有了自己的图片处理服务：[《搭建自己的图片处理服务 — 智能裁剪、旋转、占位一站搞定》](https://www.jianshu.com/p/b4db00f73ab5)\r\n都已经这么完美了，为什么还会有这篇文章呢？是对社会有什么不满意吗？\r\n![HTTPS](https://upload-images.jianshu.io/upload_images/14752545-5ed58920c69d79de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\r\n\r\n# 为什么要上 HTTPS\r\n**安全：**你与用户之间的消息加密传输，防止中间人攻击(**就是我遇到的问题**)\r\n**其它优点：**当你在国内使用域名时，需要备案。有时你想测试一下你的站，用上未备案的域名，怎么办呢？https 可以帮你暂时绕过阿里云弹的未备案页(**强烈建议去备案你的域名，一来你应当守法，二来未备案国内 cdn、网站收录什么的都需要备案的域名**)，其它暂时没想到有什么优点。\r\n\r\n# 因果\r\n前些天刚搭了个漂亮的小博客，写了几篇小日记还没有修改成小说。可以说非常开心了，于是今天早早洗完澡准备在床上用手机体验下网站自适应的效果。打开微信，扫了下自己站的二维码，顺势躺在床上。划～划～划，突然底部跳出一个广告，咦？什么情况？我什么时候投的广告？？这博客不会这么坑吧？竟然自带广告。\r\n不行，得起来撸代码了。带着懊恼的心情，我又回到了电脑前，开始检查博客的源码，看看具体哪里出了这个问题。看了一遍，没有问题。突然想到，这可能是被运营商劫持了。那没办法了，只能连夜上个 HTTPS 了。\r\n\r\n [没有服务器？ 来参加阿里云双 11 底价团，12 号前 99.5/台起！](https://m.aliyun.com/act/team1111/#/share?params=N.9g4CZ2TwSh.n2wswqow)\r\n>![优惠的一小部分](https://upload-images.jianshu.io/upload_images/14752545-847853f809e2593f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\r\n>[查看更多](https://m.aliyun.com/act/team1111/#/share?params=N.9g4CZ2TwSh.n2wswqow)\r\n\r\n# 准备\r\n* 域名（自备）\r\n* [acme.sh](http://acme.sh/)\r\nacme.sh 是一个自动申请 https 证书的脚本，使用方便，功能也非常强大。\r\n**安装：**\r\n```curl https://get.acme.sh | sh```\r\n或者\r\n ```wget -O -  https://get.acme.sh | sh```\r\n这样你已经把 acme.sh 这个小工具安装到你本地的 ```~/.acme.sh/```中了，而不会在你系统的其它地方装些乱七八糟的东西。\r\n\r\n# 极速开始\r\n**不是阿里的朋友，可以尝试下面的常规路线**\r\n阿里云购买域名的朋友可以走这个极速通道，因为阿里云有接口可以直接操作域名控制台，这个接口已经被整合到了 ```acme.sh``` 这个工具里面。只要设置一下 Ali_Key 和 Ali_Secret， [从哪里获得？](https://ak-console.aliyun.com/#/accesskey)\r\n\r\n1. 在你的命令行中执行如下命令：\r\n```export Ali_Key=\"换成你的 AccessKey ID\"```\r\n```export Ali_Secret=\"换成你的 Access Key Secret\"```\r\n\r\n2. 开始申请证书\r\n```acme.sh --issue --dns dns_ali -d 2td.cc -d '*.2td.cc'``` \r\n```2td.cc``` 是我的域名，这里需要换成你的。\r\n**参数解释:**\r\n**acme.sh** ：表示使用你刚安装好的acme.sh\r\n**--issue** ：申请证书\r\n**--dns dns_ali**：使用阿里云的 dns 服务，在阿里云买的域名，在没有修改默认 dns 的前提下，都可以使用这个参数来申请 https 证书。\r\n**-d 2td.cc**：```-d```表示 domain，后面跟你要申请域名。\r\n__-d '*.2td.cc'__：这里的-d 与上方一样，-d 参数可以带多个，这里的```'*.2td.cc'```中的 * 表示泛域名，只要申请了这个证书像（www.2td.cc，mail.2td.cc，h5.2td.cc ...）这类的二级域名都可以使用此证书来实现 https。**注意** ```2td.cc```这个域名不在这条规则里，所以上面又加了一条```-d 2td.cc```，这样你的主域名、二级子域名均可以使用此证书。\r\n\r\n3. 等待执行完成，期间会有 120 秒的倒计时，结束后如果显示成功，则证书申请成功。\r\n>![申请中...](https://upload-images.jianshu.io/upload_images/14752545-8e43c8865ca7cb4e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\r\n![申请完成](https://upload-images.jianshu.io/upload_images/14752545-05c94c2d6816d703.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\r\n![申请好的证书路径](https://upload-images.jianshu.io/upload_images/14752545-55ca990b32e2e208.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\r\n\r\n4. 应用到 nginx\r\n修改你 nginx 的配置，配置 https\r\n```\r\nserver {\r\n    listen 443 ssl;\r\n    # 有了 https 可以尝试开启 http2，加速你的网站 \r\n    # http2 需要你 nginx 加载了 http2 模块，用如下配置开启。\r\n    # listen 443 ssl http2;\r\n    server_name 2td.cc;\r\n\r\n    ssl_certificate /root/.acme.sh/2td.cc/fullchain.cer;\r\n    ssl_certificate_key /root/.acme.sh/2td.cc/2td.cc.key;\r\n\r\n    # charset koi8-r;\r\n    access_log  /var/log/nginx/host.access.log  main;\r\n    \r\n    # 下面写你之前的配置\r\n}\r\n```\r\n\r\n# 常规路线\r\n一些 DNS 服务商，没有提供 API 操作 DNS 的接口，所以整合不进这个工具里。当然我们也还是可以申请证书。\r\n这种方式的好处是, 你不需要任何服务器, 不需要任何公网 ip, 只需要 dns 的解析记录即可完成验证. 坏处是，如果不同时配置 [Automatic DNS API](https://github.com/Neilpang/acme.sh/blob/4f59a821d33281ff5a3090cbe8de47c5f0ae10ce/dnsapi/README.md)，使用这种方式 acme.sh 将无法自动更新证书，每次都需要手动再次重新解析验证域名所有权。\r\n1. 申请证书\r\n```acme.sh  --issue  --dns -d aiwdh.cn --yes-I-know-dns-manual-mode-enough-go-ahead-please```\r\n```aiwdh.cn``` 是我的域名，这里需要换成你的。\r\n**参数解释:**\r\n**acme.sh** ：表示使用你刚安装好的acme.sh\r\n**--issue** ：申请证书\r\n**--dns**：使用 DNS 的方式来验证你的所有权，你需要在域名上添加一条 txt 解析记录, 验证域名所有权。\r\n**-d aiwdh.cn**：```-d```表示 domain，后面跟你要申请域名。\r\n**--yes-I-know-dns-manual-mode-enough-go-ahead-please**:官方不推荐使用此方式来生成证书，所以有这个额外的参数来提醒你你在做什么。\r\n![申请证书](https://upload-images.jianshu.io/upload_images/14752545-a1de100dc33f1816.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\r\n\r\n\r\n2. 添加 txt 记录\r\n![添加 txt 记录](https://upload-images.jianshu.io/upload_images/14752545-70a292fa43dadd6a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\r\n\r\n3. 加好记录后，重新申请证书\r\n```acme.sh  --issue  --dns -d aiwdh.cn --yes-I-know-dns-manual-mode-enough-go-ahead-please --renew```\r\n![重新申请证书](https://upload-images.jianshu.io/upload_images/14752545-8be6488b3e4f5a0d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\r\n![申请好的证书路径](https://upload-images.jianshu.io/upload_images/14752545-aa7e33473e41c18b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\r\n4. 应用到 nginx\r\n修改你 nginx 的配置，配置 https\r\n```\r\nserver {\r\n    listen 443 ssl;\r\n    # 有了 https 可以尝试开启 http2，加速你的网站 \r\n    # http2 需要你 nginx 加载了 http2 模块，用如下配置开启。\r\n    # listen 443 ssl http2;\r\n    server_name aiwdh.cn;\r\n\r\n    ssl_certificate /root/.acme.sh/aiwdh.cn/fullchain.cer;\r\n    ssl_certificate_key /root/.acme.sh/aiwdh.cn/aiwdh.cn.key;\r\n\r\n    # charset koi8-r;\r\n    access_log  /var/log/nginx/host.access.log  main;\r\n    \r\n    # 下面写你之前的配置\r\n}\r\n```\r\n5. 这种方式添加的证书，每当证书快过期，需要重新走一下这些步骤，稍微麻烦一点。\r\n\r\n# 结语\r\n如果用极速申请的方式，很快就可以实现全站 https 了。当然第二种方式来申请证书你都不需要在自己的服务器上作操作，你可以在本地完成申请，把证书拿到各个地方去用。\r\n\r\n终于用上了 https, 再也没有多余的广告在我手机上显示了，开心。申请速度倒是很快，整理不易，且行且珍惜。\r\n[还没服务器域名？ 来参加阿里云双 11 底价团，12 号前 99.5/台起！](https://m.aliyun.com/act/team1111/#/share?params=N.9g4CZ2TwSh.n2wswqow)",
            "title": "轻松全站 HTTPS，还没用上 https (可申请泛域名证书)的朋友可以操练起来了",
            "last_reply_at": "2018-11-12T05:48:13.602Z",
            "good": false,
            "top": false,
            "reply_count": 15,
            "visit_count": 937,
            "create_at": "2018-11-07T08:17:00.617Z",
            "author": {
                "loginname": "gladmo",
                "avatar_url": "https://avatars0.githubusercontent.com/u/18359830?v=4&s=120"
            }
        },
        {
            "id": "5be911b6e161dc409d760b96",
            "author_id": "5639e5516d966e1a39996b1a",
            "tab": "share",
            "content": "![image](https://github.com/leinov/awesome-web-you-should-know/raw/master/img/logo2.png)\r\n[github 持续更新](https://github.com/leinov/awesome-web-you-should-know)\r\n\r\n## 🌏 awesome-web-you-should-know\r\n\r\n\r\n#### 🔨tool\r\n\r\n* [emoji homepage](http://emojihomepage.com/) (emoji表情)\r\n* [json editor online](http://jsoneditoronline.org/) (在线json格式转换)\r\n* [processOn](https://processon.com/;jsessionid=240B6EBC172A590374E213A3701132C2.jvm1) (流程图)\r\n* [tiny png](https://tinypng.com/) (图片压缩)\r\n* [youtube视频下载](https://www.onlinevideoconverter.com/youtube-converter) (只需一个网页链接就可下载各大视频网站视频)\r\n* [在线二维码生成](http://www.liantu.com/)\r\n* [Alexa](https://www.alexa.com/topsites) (网站全球排名)\r\n* [在线查询](https://www.supfree.net/) (很牛逼)\r\n* [the-numbers](https://www.the-numbers.com/) (电影全球票房查询)\r\n\r\n#### 💬技术&论坛\r\n\r\n* [github](https://github.com/) (全球最大代码托管社区)\r\n* [stackoverflow](https://stackoverflow.com/) (全球最大技术问答社区)\r\n* [codrops](https://tympanus.net/codrops/) (大量优秀页面效果)\r\n* [reddit](https://www.reddit.com/) (最优秀的论坛)\r\n* [medium](https://medium.com/) (各类优秀文章)\r\n* [v2ex](https://www.v2ex.com/) (用过的都说好)\r\n* [segmentfault](https://segmentfault.com/news) (思否 优秀)\r\n* [node中文社区](https://cnodejs.org/)(Node.js专业中文社区)\r\n* [博客园](https://www.cnblogs.com/leinov) (代码改变世界)\r\n* [CSDN](https://blog.csdn.net/)\r\n* [掘金](https://juejin.im) (开发者成长社区)\r\n* [infoQ](http://www.infoq.com)\r\n* [伯乐在线](http://blog.jobbole.com/)\r\n* [微信开放社区](https://developers.weixin.qq.com/community)\r\n* [react中文论坛](http://react-china.org/)\r\n* [vue论坛](https://forum.vuejs.org/top/all)\r\n\r\n#### 🎨设计&绘画类\r\n\r\n* [dribbble](https://dribbble.com/) (最优秀的ui设计网站)\r\n* [Behance](https://www.behance.net/) (最优秀的平面设计网站)\r\n* [adobe color](https://kuler.adobe.com/explore/newest/) (adobe 色盘)\r\n* [google design](http://www.google.com/design/) (谷歌设计)\r\n* [artstation](https://www.artstation.com/) (大量优秀原画)\r\n* [deviantart](https://www.deviantart.com/) (牛逼原画)\r\n* [colrd](http://colrd.com/) (色彩搭配)\r\n* [dryicons](https://dryicons.com/) (大量icon)\r\n* [UI中国](http://www.ui.cn/) (专业用户体验设计平台)\r\n* [站酷](http://www.zcool.com.cn/) (设计师互动平台 大神很多)\r\n* [UI图](http://www.uiimg.com/) (UI设计)\r\n* [UI8](https://ui8.net/)(UI设计)\r\n* [阿里巴巴矢量图标库](http://www.iconfont.cn/) (大量优秀icon)\r\n\r\n#### 🏛云课堂\r\n\r\n* [网易云课堂](http://study.163.com/)\r\n* [慕课网](http://www.imooc.com/)\r\n* [极客学院](http://www.jikexueyuan.com/)\r\n* [极客时间](https://time.geekbang.org/) (收费技术干货)\r\n* [三节课](https://www.sanjieke.cn) (产品运营收费干货)\r\n* [麦子学院](http://www.maiziedu.com/)\r\n* [北风网](http://www.ibeifeng.com/)\r\n* [好知网](http://www.howzhi.com/)\r\n* [codecademy](http://www.codecademy.com/learn)\r\n* [pluralsight](https://www.pluralsight.com/)\r\n\r\n#### 💰区块链\r\n\r\n* [火币](https://www.huobi.com/) (交易)\r\n* [巴比特](http://www.8btc.com/) (社区)\r\n* [非小号](https://www.feixiaohao.com/) (社区 全球排名)\r\n* [币乎](https://bihu.com/) (文章社区)\r\n* [迷恋猫](https://www.cryptokitties.co/)\r\n* [龙币](https://dragonex.im/zh-hans/trade/index/btc_usdt) (我就是在这上面买币的)\r\n\r\n#### ⛷ 优秀个人&组织博客\r\n\r\n* [阮一峰老师](http://www.ruanyifeng.com/blog/) (神)\r\n* [廖雪峰](https://www.liaoxuefeng.com/) (无所不通)\r\n* [腾讯全端技术团队](http://www.alloyteam.com/)\r\n* [阿里UED](http://www.aliued.cn/)\r\n* [美团技术团队](https://tech.meituan.com/)\r\n* [360奇舞团](https://75team.com/) (360大前端团队)\r\n* [粉丝日志](http://blog.fens.me/series-nodejs/)\r\n* [helloweta](https://www.helloweba.net/)",
            "title": "awesome-web-you-should-know",
            "last_reply_at": "2018-11-12T05:37:58.723Z",
            "good": false,
            "top": false,
            "reply_count": 0,
            "visit_count": 75,
            "create_at": "2018-11-12T05:37:58.723Z",
            "author": {
                "loginname": "leinov",
                "avatar_url": "https://avatars3.githubusercontent.com/u/6204210?v=4&s=120"
            }
        },
        {
            "id": "5bdb055f646a05745b7b71a4",
            "author_id": "55f019001c5978b9092e0989",
            "tab": "ask",
            "content": "最近一直在纠结于 vim 和 emacs，\r\n突然想到来cnode问下各位大佬用的都是啥？\r\nvim or emacs 你们会选哪个呢？",
            "title": "vim or emacs 能聊下各位大佬都用的什么？",
            "last_reply_at": "2018-11-12T04:09:05.715Z",
            "good": false,
            "top": false,
            "reply_count": 8,
            "visit_count": 463,
            "create_at": "2018-11-01T13:53:35.966Z",
            "author": {
                "loginname": "yuanzhhh",
                "avatar_url": "https://avatars3.githubusercontent.com/u/9876819?v=4&s=120"
            }
        },
        {
            "id": "5b3e2e8c35342ab069061298",
            "author_id": "587599e6e65101c634fc9644",
            "tab": "ask",
            "content": "子系统的注销按钮，是跳转到 SSO 的注销接口地址， 然后 SSO 清除cookie,然后 通知（发送 http 请求）给子系统清除 session。 \r\n\r\n但是当重新刷新子系统页面的时候，session 还是存在的， 尴尬， \r\n\r\n注销的代码如下， 求大佬指教\r\n\r\n![image.png](//static.cnodejs.org/FtvN5XV0m3kTGWYgB28Lpnob8kqh)\r\n\r\n![image.png](//static.cnodejs.org/FqLzwoaM1NA9DC9w4n_WKfxjGG67)",
            "title": "关于 SSO 单点注销， SSO如何通知子系统清除凭证？",
            "last_reply_at": "2018-11-12T03:51:01.646Z",
            "good": false,
            "top": false,
            "reply_count": 8,
            "visit_count": 1409,
            "create_at": "2018-07-05T14:43:24.397Z",
            "author": {
                "loginname": "zhongxia245",
                "avatar_url": "https://avatars0.githubusercontent.com/u/7597581?v=4&s=120"
            }
        },
        {
            "id": "5be8f13ae161dc409d760acb",
            "author_id": "51ece401f4963ade0e95513a",
            "tab": "share",
            "content": "> 本篇主要是对`uv_prepare_t`句柄的介绍\r\n\r\n## uv_prepare_t声明\r\n还是从[uv.h](https://github.com/nodejs/node/blob/master/deps/uv/include/uv.h#L754)切入，便能找到关于`uv_prepare_t`的声明：\r\n```c\r\nstruct uv_prepare_s {\r\n  UV_HANDLE_FIELDS\r\n  UV_PREPARE_PRIVATE_FIELDS\r\n};\r\n```\r\n其中的私有宏`UV_PREPARE_PRIVATE_FIELDS`展开如下：\r\n```c\r\n#define UV_PREPARE_PRIVATE_FIELDS                                             \\\r\n  uv_prepare_cb prepare_cb;                                                   \\\r\n  void* queue[2];                                                             \\\r\n```\r\n`uv_prepare_t`可谓是中规中矩了，只有一个回调，以及一个句柄队列指针。而这个句柄为何起名叫prepare，则是因为`uv__run_prepare`会在`uv__io_poll`阻塞进程之前运行。\r\n\r\n## prepare 相关api\r\n视线转移到[loop-watche.c](https://github.com/nodejs/node/blob/master/deps/uv/src/unix/loop-watcher.c#L66)中：\r\n```c\r\nUV_LOOP_WATCHER_DEFINE(prepare, PREPARE)\r\n```\r\n把这个宏展开如下：\r\n```c\r\n#define UV_LOOP_WATCHER_DEFINE(name, type)                                    \\\r\n  int uv_##name##_init(uv_loop_t* loop, uv_##name##_t* handle) {              \\\r\n    uv__handle_init(loop, (uv_handle_t*)handle, UV_##type);                   \\\r\n    handle->name##_cb = NULL;                                                 \\\r\n    return 0;                                                                 \\\r\n  }                                                                           \\\r\n                                                                              \\\r\n  int uv_##name##_start(uv_##name##_t* handle, uv_##name##_cb cb) {           \\\r\n    if (uv__is_active(handle)) return 0;                                      \\\r\n    if (cb == NULL) return UV_EINVAL;                                         \\\r\n    QUEUE_INSERT_HEAD(&handle->loop->name##_handles, &handle->queue);         \\\r\n    handle->name##_cb = cb;                                                   \\\r\n    uv__handle_start(handle);                                                 \\\r\n    return 0;                                                                 \\\r\n  }                                                                           \\\r\n                                                                              \\\r\n  int uv_##name##_stop(uv_##name##_t* handle) {                               \\\r\n    if (!uv__is_active(handle)) return 0;                                     \\\r\n    QUEUE_REMOVE(&handle->queue);                                             \\\r\n    uv__handle_stop(handle);                                                  \\\r\n    return 0;                                                                 \\\r\n  }                                                                           \\\r\n                                                                              \\\r\n  void uv__run_##name(uv_loop_t* loop) {                                      \\\r\n    uv_##name##_t* h;                                                         \\\r\n    QUEUE queue;                                                              \\\r\n    QUEUE* q;                                                                 \\\r\n    QUEUE_MOVE(&loop->name##_handles, &queue);                                \\\r\n    while (!QUEUE_EMPTY(&queue)) {                                            \\\r\n      q = QUEUE_HEAD(&queue);                                                 \\\r\n      h = QUEUE_DATA(q, uv_##name##_t, queue);                                \\\r\n      QUEUE_REMOVE(q);                                                        \\\r\n      QUEUE_INSERT_TAIL(&loop->name##_handles, q);                            \\\r\n      h->name##_cb(h);                                                        \\\r\n    }                                                                         \\\r\n  }                                                                           \\\r\n                                                                              \\\r\n  void uv__##name##_close(uv_##name##_t* handle) {                            \\\r\n    uv_##name##_stop(handle);                                                 \\\r\n  }\r\n```\r\n可以看出，这个宏模板提供了几个方法，分别为：init、start、stop、close以及run。\r\n- init: 初始化句柄，并设置句柄回调为空\r\n- start: 修改句柄状态为活跃状态，其中`uv__handle_start`宏展开如下：\r\n```c\r\n// node/blob/master/deps/uv/src/uv-common.h\r\n\r\n#define uv__handle_start(h)                                                   \\\r\n  do {                                                                        \\\r\n    if (((h)->flags & UV_HANDLE_ACTIVE) != 0) break;                          \\\r\n    (h)->flags |= UV_HANDLE_ACTIVE;                                           \\  // 设置为活跃句柄\r\n    if (((h)->flags & UV_HANDLE_REF) != 0) uv__active_handle_add(h);          \\ // 活跃句柄计数+1\r\n  }                                                                           \\\r\n  while (0)\r\n```\r\n- run: 供事件循环(`uv_run`)调用以触发回调函数运行，在这里需要注意一点：\r\n```c\r\n      QUEUE_REMOVE(q);                                                        \\\r\n      QUEUE_INSERT_TAIL(&loop->name##_handles, q);                            \\\r\n```\r\n在句柄队列执行了`QUEUE_REMOVE`之后，队列中的句柄并没有真正被移除，而是又通过`QUEUE_INSERT_TAIL`插入到了队尾，意即**运行`loop-watcher`句柄(`uv_prepare_t`/`uv_check_t`/`uv_idle_t`)并不会清除句柄队列**\r\n- stop: 修改句柄状态为停止状态，其中`uv__handle_stop`宏展开如下：\r\n```c\r\n// node/blob/master/deps/uv/src/uv-common.h\r\n\r\n#define uv__handle_stop(h)                                                    \\\r\n  do {                                                                        \\\r\n    if (((h)->flags & UV_HANDLE_ACTIVE) == 0) break;                          \\\r\n    (h)->flags &= ~UV_HANDLE_ACTIVE;                                          \\ // 设置为非活跃句柄\r\n    if (((h)->flags & UV_HANDLE_REF) != 0) uv__active_handle_rm(h);           \\ // 活跃句柄计数-1\r\n  }                                                                           \\\r\n  while (0)\r\n```\r\n- close：关闭句柄。通过`uv_prepare_stop`实现\r\n\r\n## loop-watcher 事件循环监视器句柄\r\n通过`uv_prepare_t`我们可以引入一个概念：事件循环监视器。这些监视器有一个共性就是：**运行完成后不会清除句柄队列**。这里的监视器指的是`loop-watcher`中定义的句柄：\r\n```c\r\nUV_LOOP_WATCHER_DEFINE(prepare, PREPARE)\r\nUV_LOOP_WATCHER_DEFINE(check, CHECK)\r\nUV_LOOP_WATCHER_DEFINE(idle, IDLE)\r\n```\r\n即：`uv_prepare_t`/`uv_check_t`/`uv_idle_t`。  \r\n\r\n## node中对uv_prepare_t的应用\r\n在[env.cc](https://github.com/nodejs/node/blob/master/src/env.cc#L385)中，可发现如下代码：\r\n```c++\r\nvoid Environment::StartProfilerIdleNotifier() {\r\n  if (profiler_idle_notifier_started_)\r\n    return;\r\n\r\n  profiler_idle_notifier_started_ = true;\r\n\r\n  uv_prepare_start(&idle_prepare_handle_, [](uv_prepare_t* handle) {\r\n    Environment* env = ContainerOf(&Environment::idle_prepare_handle_, handle);\r\n    env->isolate()->SetIdle(true);\r\n  });\r\n\r\n  uv_check_start(&idle_check_handle_, [](uv_check_t* handle) {\r\n    Environment* env = ContainerOf(&Environment::idle_check_handle_, handle);\r\n    env->isolate()->SetIdle(false);\r\n  });\r\n}\r\n```\r\n其中的`uv_prepare_start`真正唤醒了prepare handle，node通过libuv的prepare句柄注册`SetIdle`，下面是`SetIdle`的源码：\r\n```c++\r\nvoid Isolate::SetIdle(bool is_idle) {\r\n  if (!is_profiling()) return;\r\n  StateTag state = current_vm_state();\r\n  DCHECK(state == EXTERNAL || state == IDLE);\r\n  if (js_entry_sp() != kNullAddress) return;\r\n  if (is_idle) {\r\n    set_current_vm_state(IDLE);\r\n  } else if (state == IDLE) {\r\n    set_current_vm_state(EXTERNAL);\r\n  }\r\n}\r\n```\r\n结合上面代码的`profiler_idle_notifier_started_`。可以发现，node在event-loop的`uv_run_prepare`阶段来通知此时vm(v8)的状态。 \r\n\r\n\r\n\r\n原文地址：[https://github.com/xtx1130/blog/issues/33](https://github.com/xtx1130/blog/issues/33)， 如果文中有误，还请大神斧正\r\nby 小菜",
            "title": "libuv源码粗读（4）：uv_prepare_t预处理句柄结构体介绍",
            "last_reply_at": "2018-11-12T03:19:22.156Z",
            "good": false,
            "top": false,
            "reply_count": 0,
            "visit_count": 91,
            "create_at": "2018-11-12T03:19:22.156Z",
            "author": {
                "loginname": "xtx1130",
                "avatar_url": "https://avatars2.githubusercontent.com/u/5475069?v=4&s=120"
            }
        },
        {
            "id": "5be8ee432fed25406c25d8f2",
            "author_id": "5639e5516d966e1a39996b1a",
            "tab": "share",
            "content": "https://github.com/leinov/node-weixin-api",
            "title": "Nodejs微信公众号开发",
            "last_reply_at": "2018-11-12T03:06:43.197Z",
            "good": false,
            "top": false,
            "reply_count": 0,
            "visit_count": 149,
            "create_at": "2018-11-12T03:06:43.197Z",
            "author": {
                "loginname": "leinov",
                "avatar_url": "https://avatars3.githubusercontent.com/u/6204210?v=4&s=120"
            }
        },
        {
            "id": "5be8eb2d2fed25406c25d8a2",
            "author_id": "5be8e9ef2fed25406c25d88c",
            "tab": "share",
            "content": "最近看了 mv shelter，心里迟迟不能平静。\r\n痛苦，孤寂，绝望..\r\n好的剧情真的可以震撼心灵！突然有了强烈的创作欲望！\r\n身为程序员，当然选择在命令行上跳舞，命令行上的幻想世界...互动小说!\r\n\r\n于是先 lu 出来了一个框架: cmd-alive\r\n\r\n## Usage\r\n```\r\n  npm i -g alive\r\n```\r\n// 默认打开 demo。自动从上次进度开始。\r\n```\r\n  alive\r\n```\r\n命令:\r\n* save: 保存进度\r\n* restart: 重新开始\r\n\r\n## 面向小说作者（ opitional ）\r\n\r\n\r\n\r\n两种文件是必须的 .js, .ca.\r\n\r\n* .ca：小说内容，每一节要有 label 标识. 必须包括start, end label\r\n\r\n* .js：流程控制，js 函数， 函数名和返回值必须是 label。可以访问全局对象 ctx，用来获取当前用户输入，过去用户输入，挂载状态等等，辅助实现 game 逻辑.\r\n\r\n示例 ： .ca:\r\n```\r\n$start: \r\nA nice day.\r\n\r\nchoices:\r\n\r\na. go to 2a.\r\nb. go to A LOOP.\r\n\r\n\r\n$2a: \r\nThen?\r\nNo choice.\r\n\r\n$loop: \r\nYou can't excape.\r\n\r\n$end: \r\nThink you.\r\n```\r\n\r\n.js\r\n```\r\nfunction $start() {\r\n  if (ctx.cur === \"b\") {\r\n    return $loop;\r\n  }\r\n  if (ctx.cur == \"a\") {\r\n    return $2a;\r\n  }\r\n  return $start;\r\n}\r\n\r\nfunction $2a() {\r\n  return $end;\r\n}\r\n\r\nfunction $loop() {\r\n  return $start;\r\n}\r\nfunction $end() {\r\n  // dumb\r\n}\r\n```\r\n参考 demo(文件位置 /example/shelter)\r\n### repo： https://github.com/derekchuank/cmd-alive",
            "title": "互动小说框架分享",
            "last_reply_at": "2018-11-12T02:53:33.762Z",
            "good": false,
            "top": false,
            "reply_count": 0,
            "visit_count": 110,
            "create_at": "2018-11-12T02:53:33.762Z",
            "author": {
                "loginname": "derekchuank",
                "avatar_url": "https://avatars1.githubusercontent.com/u/40260204?v=4&s=120"
            }
        },
        {
            "id": "5bcc139215e4fd1923f4911f",
            "author_id": "5b52cbf1fb9e84ec69cc1ca2",
            "tab": "share",
            "content": "egg-cnode开源程序搭建的网站已经上线\r\n\r\n**地址**：http://bbs.itying.com/\r\n\r\n感谢cnode的开源程序",
            "title": "cnode 的源码egg-cnode开源程序搭建的网站已经上线--感谢cnode",
            "last_reply_at": "2018-11-12T02:24:04.176Z",
            "good": false,
            "top": false,
            "reply_count": 11,
            "visit_count": 868,
            "create_at": "2018-10-21T05:50:10.601Z",
            "author": {
                "loginname": "nodeper",
                "avatar_url": "https://avatars2.githubusercontent.com/u/41500847?v=4&s=120"
            }
        },
        {
            "id": "5be8dcf82fed25406c25d805",
            "author_id": "597ee3db68aa87c774e5edac",
            "tab": "share",
            "content": "![稿定设计导出-20181108-204711.png](//static.cnodejs.org/Fo8_CVsdQq6R9DF1Wp34_HkhobF8)\r\n\r\n编者注：俗话说的好 **“并发不够，机器来凑”**，当我们面对高并发请求的时候增加机器是最简单也是最土豪的做法。不过在资源有限的情况除了去优化代码我们又该怎么办呢？今天我们请来了 @有马 同学为我们分享一下他在这方面的经验，希望能帮助到大家。\r\n\r\n———\r\n\r\n想要开发牢固的Web API只考虑安全是不够的，还有一点我们需要考虑，那就是应对大规模访问的对策。不仅是Web API服务，任何在网络上公开的服务都会时不时地遇到来自外部的大规模访问，比如“鹿晗关晓彤公布恋情”这种实时热点。当服务器遇到大规模访问时，为了处理这些访问会耗尽资源，进而无法提供服务。这时不仅是这些大规模访问，任何人都无法和服务器端建立连接。\r\n\r\n我们可以通过程序毫不费力的访问Web API，所以API服务器更容易遇到访问负载高的情况，针对这个问题，和普通的Web应用一样，我们可以对API服务进行扩容，这是正确的做法，但本文不对扩容方案展开讨论。接下来会讨论限速在应对大规模访问时一些重要的点，以及在ThinkJS开发的项目中应该怎样做。\r\n\r\n## 限制用户的访问\r\n为了解决突然出现大规模访问的问题，最现实的方法是对每个用户的访问次数进行限制。也就是确定单个用户在单位时间里最大的访问次数，如果用户已经超过了最大访问次数，用户再次访问时，服务端将会直接拒绝并返回错误信息。比如设置一个用户10分钟内只允许调用20次获取短信验证码的接口，那么当用户在10分钟内发起第21次请求时，服务器端便会返回错误信息，10分钟之后才会恢复访问。如果进行访问限速，就要先解决下面三个问题：\r\n\r\n* 如何确定限速的数值\r\n* 如何确定限速时间单位\r\n* 在什么时候重置限速的数值\r\n\r\n### 确定限速数值\r\n\r\n对数据频繁更新的查询类API而言，用户需要频繁的访问的到最新的数据，如果设置1小时只能访问10次的话，用户肯定不满意，转而去用可以替代的服务。访问限速的初衷是为了应对服务器短时间内遭遇大规模访问不堪重负从而无法提供服务，但如果让用户用起来不方便就得不偿失了，所以要尽可能的了解提供的API在什么情况下被使用，然后决定限速的数值。\r\n\r\n### 确定限速时间单位\r\n\r\n根据在线服务的不同，有些会以一天作为访问次数的时间单位，不过这对很多API来说有点长了，假设使用者正在写脚本访问API，开始并不清楚访问次数的时间单位，那就可能需要让他等24个小时才能继续访问API，或者换一个账号。如果我们以10分钟作为访问次数的时间单位，如果超出访问次数限制，也只需要等10分钟就能继续访问了。虽然单位时间的设定和API返回的数据密切相关，但大部分已公开的API都设置了都设置了1小时左右的单位时间。\r\n\r\n### 确定重置限速数值的时间\r\n\r\n当用户超出访问上限值时，服务端该如何返回响应消息呢？这种情况下可以返回HTTP协议中备好的“429 Too Many Request”状态码。429状态码在2012年4月发布的RFC 6585中定义，当特定用户在一定时间内发起的请求次数过多时，服务器端可以返回该状态码表示出错。RFC 文档中对该状态码描述如下：\r\n\r\n```\r\n429 Too Many Requests\r\n\r\n   The 429 status code indicates that the user has sent too many\r\n   requests in a given amount of time (\"rate limiting\").\r\n\r\n   The response representations SHOULD include details explaining the\r\n   condition, and MAY include a Retry-After header indicating how long\r\n```\r\n\r\n通过上面的描述可以知道，响应消息中应该包含错误的详细信息，并且可以通过`Retry-After`告知用户需要等待多长时间才能访问API。[Retry-After](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After)首部表示客户端需要等待多长时间才能再次访问。RFC文档中用 `MAY` 标记该首部，表示即使不发送该首部也不会有什么问题，只是在响应体加上该首部会显得更加友好。\r\n\r\n另外，`Retry-After`并不是 429 状态码专用的响应首部。该首部在HTTP 1.1的RFC 7231中定义，它也同样包含在带有503和3xx系列的响应体中。而且`Retry-After`首部用秒数来指定时间，还可以使用详细的日期信息，可以看一下RFC文档中的描述：\r\n\r\n```\r\nRetry-After\r\n\r\n   Servers send the \"Retry-After\" header field to indicate how long the\r\n   user agent ought to wait before making a follow-up request.  When\r\n   sent with a 503 (Service Unavailable) response, Retry-After indicates\r\n   how long the service is expected to be unavailable to the client.\r\n   When sent with any 3xx (Redirection) response, Retry-After indicates\r\n   the minimum time that the user agent is asked to wait before issuing\r\n   the redirected request.\r\n\r\n   The value of this field can be either an HTTP-date or a number of\r\n   seconds to delay after the response is received.\r\n\r\n     Retry-After = HTTP-date / delay-seconds\r\n\r\n   A delay-seconds value is a non-negative decimal integer, representing\r\n   time in seconds.\r\n\r\n     delay-seconds  = 1*DIGIT\r\n```\r\n \r\n## 通过HTTP响应传递限速信息\r\n\r\n在实施访问限速的过程中，如果能将当前用户访问次数限制、已使用的访问次数以及何时重置访问限速等信息告诉用户，会显得非常友好。如果不返回这些信息的话，用户可能为了确定限速是否解除而多次尝试访问接口API，这样一来无疑又增加了服务器的压力。\r\n\r\n限速信息可以放在响应消息首部，另一种是作为响应消息体数据的一部分，目前将限速信息放在响应消息首部的方式成为事实上的标准。\r\n\r\n|首部名|说明|类型|\r\n|----|----|----|\r\n|X-RateLimit-Limit|单位时间的访问上限|Integer|\r\n|X-RateLimit-Remaining|剩余的访问次数|Integer|\r\n|X-RateLimit-Reset|访问次数重置时间|UTC epoch seconds|\r\n\r\n看一下[GitHub的限速策略](https://developer.github.com/v3/#rate-limiting)，GitHub就使用了上面三个响应首部，没有带`Retry-After`首部。对于认证的请求每小时可以访问5000次，没有认证的请求每小时访问60次。\r\n\r\n而[Twitter限速策略](https://developer.twitter.com/en/docs/basics/rate-limiting.html)的时间窗口是15分钟，比GitHub的时间窗口小很多，因为Twitter的数据更新的相对较较快，时间窗口设置小一些才能满足使用者获取最新数据的需求。Twitter使用类似上面三个的响应首部传达限速信息`x-rate-limit-limit`,`x-rate-limit-remaining`,`x-rate-limit-reset`。对于GET请求有两种初始方案，一种是15分钟15次请求，另一种是15分钟180次请求，并且只允许认证访问。\r\n\r\n通过对比GitHub和Twitter的限速策略，可以知道只要准确传达限速信息，响应头部完全可以自己定义，重点是语义明确，且不能和其他标准首部冲突。\r\n\r\n## 在ThinkJS中实现API限速控制\r\n\r\n要实现API访问限速，需要对每个用户及应用访问API的次数进行计数，一般会使用`Redis`等键值对存储来记录。ThinkJS 结合自己的路由映射方式实现了[think-ratelimiter](https://github.com/thinkjs/think-ratelimiter)中间件对`action`进行限速，你需要在`middleware.js`里进行如下配置，就可以实现简单的限速策略。\r\n\r\n```javascript\r\n// in middleware.js\r\nconst redis = require('redis');\r\nconst { port, host, password } = think.config('redis');\r\nconst db = redis.createClient(port, host, { password });\r\nconst ratelimiter = require('think-ratelimiter');\r\n\r\nmodule.exports = {\r\n  // after router middleware\r\n  {\r\n    handle: ratelimiter,\r\n    options: {\r\n      db,\r\n      errorMessage: 'Sometimes You Just Have To Slow Down',\r\n      headers: {\r\n        remaining: 'X-RateLimit-Remaining',\r\n        reset: 'X-RateLimit-Reset',\r\n        total: 'X-RateLimit-Limit'\r\n      },\r\n      resources: {\r\n        'test/test': { // key 是 controller/action 的拼接\r\n          id: ctx => ctx.ip,\r\n          max: 5,\r\n          duration: 7000 // ms\r\n        }\r\n      }\r\n    }\r\n  },\r\n}\r\n```\r\n\r\n响应体首部`X-RateLimit-Reset`表示可以恢复访问的时间，同时也会带着`Retry-After`首部，它的值是距离恢复时间的秒数。\r\n\r\n## 总结\r\n\r\n在ThinkJS开发的Web应用中，可以使用中间件然后添加配置实现简单的限速，如果你提供的web API服务访问量比较大或者需要付费访问等功能，就需要在真正的逻辑前加一层来做限速相关的事情，在ThinkJS中可以实现一个`services/ratelimit.js`，然后在项目的`base controller`中实现限速等逻辑。\r\n\r\n**参考资料：**\r\n\r\n* [《Web API的设计与开发》](https://book.douban.com/subject/27054104/)\r\n* [RFC 6585](https://datatracker.ietf.org/doc/rfc6585/)\r\n* [RFC 7231](https://tools.ietf.org/pdf/rfc7231.pdf)\r\n* [Retry-After](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After)",
            "title": "API开发中如何使用限速应对大规模访问",
            "last_reply_at": "2018-11-12T01:52:56.653Z",
            "good": false,
            "top": false,
            "reply_count": 0,
            "visit_count": 125,
            "create_at": "2018-11-12T01:52:56.653Z",
            "author": {
                "loginname": "lizheming",
                "avatar_url": "https://avatars2.githubusercontent.com/u/424491?v=4&s=120"
            }
        },
        {
            "id": "5be6cffb646a05745b7ba792",
            "author_id": "580c1addc3fead57507172a9",
            "tab": "ask",
            "content": "在小程序中 接口返回的值是0.331325 使用toFixed(4)再乘100 以便百分比展示 结果得到了33.1299999999995% 和小程序环境有关系吗？还是toFixed(4) 本身有坑呢？怎么解决这个bug呢？",
            "title": "toFixed失灵",
            "last_reply_at": "2018-11-12T01:43:29.873Z",
            "good": false,
            "top": false,
            "reply_count": 6,
            "visit_count": 274,
            "create_at": "2018-11-10T12:32:59.148Z",
            "author": {
                "loginname": "jowang2016",
                "avatar_url": "https://avatars1.githubusercontent.com/u/18169317?v=4&s=120"
            }
        },
        {
            "id": "5be69602646a05745b7ba710",
            "author_id": "59817d2328607f916122dbb9",
            "tab": "ask",
            "content": "服务器是腾讯云的，证书已经颁发了，但express默认搭建的是http服务器，我想把他转为https，要如何操作，求教",
            "title": "如何用Express搭建一个https服务器",
            "last_reply_at": "2018-11-12T01:40:06.578Z",
            "good": false,
            "top": false,
            "reply_count": 2,
            "visit_count": 257,
            "create_at": "2018-11-10T08:25:38.241Z",
            "author": {
                "loginname": "972389149",
                "avatar_url": "https://avatars3.githubusercontent.com/u/30545614?v=4&s=120"
            }
        },
        {
            "id": "5b52cc67fb9e84ec69cc1ca3",
            "author_id": "5b52cbf1fb9e84ec69cc1ca2",
            "tab": "ask",
            "content": "哪里有Nodejs入门教程-对我菜鸟来说有视频最好谢谢大家。老铁们帮帮忙推荐推荐。",
            "title": "哪里有Nodejs入门教程-对我菜鸟来说有视频最好谢谢大家",
            "last_reply_at": "2018-11-11T09:00:40.980Z",
            "good": false,
            "top": false,
            "reply_count": 37,
            "visit_count": 3218,
            "create_at": "2018-07-21T06:02:15.043Z",
            "author": {
                "loginname": "nodeper",
                "avatar_url": "https://avatars2.githubusercontent.com/u/41500847?v=4&s=120"
            }
        },
        {
            "id": "5be2bbdf21d75b74609f515e",
            "author_id": "57de06085710e2ed658d6bd4",
            "tab": "ask",
            "content": "性别：女，92年生，英语：6级，之前做外贸公司跟单销售，现想寻求一份跟英语相关的工作！如有此类工作，请留言，万分感谢！",
            "title": "有没有互联网公司需要英语专业的人才员",
            "last_reply_at": "2018-11-11T07:39:17.279Z",
            "good": false,
            "top": false,
            "reply_count": 6,
            "visit_count": 480,
            "create_at": "2018-11-07T10:18:07.878Z",
            "author": {
                "loginname": "duzitengg",
                "avatar_url": "https://avatars2.githubusercontent.com/u/21256522?v=4&s=120"
            }
        },
        {
            "id": "5be7ce7f21d75b74609f628a",
            "author_id": "560b3a2848055cd15e2c8957",
            "tab": "share",
            "content": "NutzWk 5.1.0 Vue版本已发布，演示地址： [https://nutzwk.wizzer.cn](https://nutzwk.wizzer.cn)\r\n\r\n源码Github：[https://github.com/Wizzercn/NutzWk](https://github.com/Wizzercn/NutzWk)\r\n码云Gitee：[https://gitee.com/wizzer/NutzWk](https://gitee.com/wizzer/NutzWk)\r\n\r\n本次更新内容：\r\n* wk-nb-web-vue 新增全新的Vue后台管理界面，基于Vue.js + Element.js 等，增强交互体验；\r\n* 基础服务类 BaseService 新增一些常用的查询方法；\r\n* 微信模块增加图片自动回复、群发图片、微信菜单可配小程序等功能；\r\n* CMS模块增加前台模板标签示例代码；\r\n* 增强Oracle及MySQL兼容性；\r\n* 支持Openjdk 11；\r\n\r\n后端技术架构：java nutzboot + dubbo + zookeeper\r\n前端技术架构：vue.js + element.js + bootstrap",
            "title": "NutzWk 5.1.0 微服务开发框架，Vue版本已发布",
            "last_reply_at": "2018-11-11T06:38:55.029Z",
            "good": false,
            "top": false,
            "reply_count": 0,
            "visit_count": 193,
            "create_at": "2018-11-11T06:38:55.029Z",
            "author": {
                "loginname": "Wizzercn",
                "avatar_url": "https://avatars0.githubusercontent.com/u/2408114?v=4&s=120"
            }
        },
        {
            "id": "5be7c16e21d75b74609f622f",
            "author_id": "5a94076871327bb413bbfe96",
            "tab": "ask",
            "content": "拉取七牛列表获取文件信息，一直都很正常。突然发现现在获取列表时，不返还下一页的marker。只返回了文件列表。\r\n初步猜测是有文件删除导致的。是不是有文件删除会导致maker被重置的可能。有没有类似经历的大神呀。",
            "title": "七牛获取文件列表，没有返还下一个列表的maker",
            "last_reply_at": "2018-11-11T06:05:14.712Z",
            "good": false,
            "top": false,
            "reply_count": 1,
            "visit_count": 111,
            "create_at": "2018-11-11T05:43:10.122Z",
            "author": {
                "loginname": "SharksevenRo",
                "avatar_url": "https://avatars3.githubusercontent.com/u/8946077?v=4&s=120"
            }
        },
        {
            "id": "5bd9177ed00aac1004de5300",
            "author_id": "5639e5516d966e1a39996b1a",
            "tab": "share",
            "content": "@subject: wepy-redux-time-todo   \r\n@author: leinov   \r\n@date:2018-10-30   \r\n@notice: 小程序(wepy)开发群110647537 欢迎加入\r\n# wepy-redux-time-todo\r\n![image](https://github.com/leinov/leinov.github.io/raw/master/img/timeredux.gif)\r\n## Use [github地址](https://github.com/leinov/wepy-redux-time-todo)\r\n```\r\ngit clone git@github.com:leinov/wepy-redux-time-todo.git\r\n\r\nnpm install\r\n\r\nnpm run dev\r\n```\r\n添加到微信开发者工具里即可运行\r\n## Wiki\r\n### 创建项目\r\nwepy是腾讯自出的一套小程序框架，基于Vue写法，也可以灵活使用第三方库，对原生的api也做了部分优化，提高了整体代码的可读性和可维护性，也极大的提高了开发效率，极力推荐使用。首先需要安装wepy命令，通过命令创建wepy项目，在执行下面第二句命令过程中会有一些问题，在到是否使用redux的问题时选y，在创建时就会加入redux依赖以及store文件夹\r\n```\r\nnpm install wepy-cli -g //安装全局wepy命令\r\n\r\nwepy init standard wepy-redux-time-todo // 创建wepy-redux-time-todo项目\r\n```\r\n\r\n### 项目结构\r\n执行创建命令后会出现类似以下结构的项目结构(下面是我自己创建文件后的)\r\n```\r\n |-- dist // 编译后执行文件夹\r\n |-- node_modules\r\n |-- src // 开发文件夹\r\n |   |-- components //组件\r\n        |-- sec-title.wpy\r\n     |-- pages //业务页面\r\n        |-- index.wpy\r\n     |-- store // redux\r\n        |-- actions\r\n            |-- index.js\r\n        |-- reducers\r\n            |-- timeReducer.js\r\n            |-- index.js //合并reducer\r\n        |-- types\r\n            |-- index.js\r\n     |-- style //样式\r\n        |-- weui.scss\r\n     |-- app.wpy //入口\r\n |-- package.json\r\n```\r\n\r\n### Redux概念以及使用\r\n\r\n\r\nRedux主要的作用是管理复杂的数据，多用于操作单页应用中的复杂状态，将整个应用的状态集中放在一个容器里统一管理。作为一个状态容器，他就像一个盒子(store)，这个唯一的盒子(整个应用只有一个store)里有很多状态(state), 都以一个对象树的形式储存在store 中。 **唯一能改变 state 的办法是触发 action**，action是一个简单的对象，用来描述你想要干什么。reducer是一个纯函数来根据action返回的type操作状态变化返回新状态，reducer作为createStore参数返回最新的store，下面我们通过redux官网的代码具体描述redux的执行过程，\r\n\r\n\r\n#### Action\r\n\r\naction可以理解为动作，用户希望干什么，比如点击一个按钮让页面的数字加1，切换日期，插入数组等，总之是一个希望页面状态发生改变的行为标识。action用一个对象表示,包含一个必须属性```type```\r\n```\r\n{type:\"INCREMENT\"} //表示添加动作\r\n{type:\"DECREMENT\"} //表示减法动作\r\n{type:\"GET_DATA\",payload:{}} // 表示获取数据动作并挂载一个数据在payload属性上供reducer使用，多用于异步获取数据，也可以用自己的添加其他属性\r\n```\r\n#### Reducer\r\n\r\nreducer是一个形式为 (state, action) => state 的纯函数（纯函数概念：不依赖外部环境变量，只依赖内部参数、不会产生副作用、相同的输入确保相同的输出）。描述了 action 如何把 state 转变成下一个 state。state 的形式取决于你自己，可以是基本类型、数组、对象、甚至是 Immutable.js 生成的数据结构。唯一的要点是当 state  变化时需要返回全新的对象，而不是修改传入的参数。\r\n下面例子使用 `switch` 语句和字符串来做判断，也可以用自己的方式。\r\n\r\n```\r\nfunction reducer(state = 0, action) {\r\n  switch (action.type) {\r\n  case 'INCREMENT':\r\n    return state + 1;\r\n  case 'DECREMENT':\r\n    return state - 1;\r\n  default:\r\n    return state;\r\n  }\r\n}\r\n```\r\n\r\n#### store\r\n\r\nredux的createStore方法用于创建应用唯一的store，createStore方法的**参数**即reducer，用于更新store内state树，通过以下创建就可以把一个初始的{state:0}的这样一个状态存入到store中\r\n```\r\nimport { createStore } from 'redux';\r\n\r\nconst store = createStore(reducer);\r\n```\r\nstore有几个重要的方法\r\n* ```store.dispatch(action)```  //派发事件 表示要干什么\r\n* ```store.getState()``` // 获取存储在store里的所有状态(数据)\r\n* ```store.subscribe(listener)``` //手动监听状态变化\r\n\r\n#### dispatch改变状态\r\n\r\nstore.dispatch是改变状态的唯一方式，dispatch接受一个action参数（做什么），通知reducer需要做出什么样的改变，再更新整个store\r\n```\r\nstore.dispatch({INCREMENT:\"INCREMENT\"}) \r\n```\r\n这个操作会告诉reducer 当前需要给state做加1操作，\r\n#### 获取state\r\n```\r\nstore.getState() // {state:1}\r\n```\r\n\r\n### subscribe监听\r\n```\r\nstore.subscribe(() =>\r\n  console.log(store.getState())\r\n);\r\n```\r\n在dispatch触发状态更新后需要通过subscribe监听才能获得最新的状态，如果在react中使用则需要把视图渲染函数放在监听函数内。\r\n```\r\nimport store from \"./redux.js\"\r\nstore.subscribe(()=>{\r\n  ReactDOM.render(<App />, document.getElementById('root'))\r\n});\r\n```\r\n> 以上是纯redux的使用，使用起来比较鸡肋，redux大量被使用在react项目中，封装库react-redux提供的Provider和connect可以将react和redux完美结合，使用非常方便。\r\n\r\n\r\n### Redux在wepy中的使用\r\n通过上面的描述应该对redux有了一定的了解，接下来我们看下redux在小程序框架wepy中如何使用，wepy中需要安装wepy-redux依赖，类似react-redux，store文件夹下放redux的操作代码，redux的使用方法都相同，这里我们讲下与react使用不一样的地方\r\n\r\n#### 初始化store\r\n首先需要在app.wpy中初始化store\r\n```\r\nimport { setStore } from 'wepy-redux'\r\nimport configStore from './store'\r\n\r\nconst store = configStore()\r\nsetStore(store)\r\n```\r\nwepy中app.wpy编译后为原生小程序中的app.js，app.js在小程序整个执行生命周期里处于最前端，在小程序初始化时来创建store，这样在所有页面都可以使用，等同于react里的Provider\r\n\r\n#### redux-actions\r\n这里使用```redux-actions```库来优化reducer里的```switch```写法。\r\n```\r\nimport { handleActions } from \"redux-actions\";\r\nimport {\r\n\tTIME_CONFIG_DATA, // 学员\r\n} from \"../types/index\";\r\n\r\nexport default handleActions({\r\n\t[TIME_CONFIG_DATA](state, action) {\r\n\t\treturn {\r\n\t\t\t...state,\r\n\t\t\ttimeConfigData: action.newData\r\n\t\t};\r\n\t}\r\n}, {\r\n\ttimeConfigData:[], //state初始值 \r\n});\r\n```\r\n\r\n#### connect连接到wepy组件上\r\nconnect(states, actions) connect有两个参数，states是整个应用的状态，页面需要使用哪个状态对应获取该状态即可,actions业务操作，是wepy-redux对action的封装，这里我们不用这种方式，自己在action中手动dispatch，如果想要了解详细使用可参考[wepy-redux](https://www.npmjs.com/package/wepy-redux) \r\n```\r\nimport { connect } from 'wepy-redux'\r\n @connect({\r\n    timeConfigData(state) {\r\n      return state.timeReducer.num\r\n    }\r\n  })\r\n  export default class Index extends wepy.page {\r\n  \t// ...\r\n    methods = {\r\n      // ...\r\n    }\r\n    // ...\r\n    onLoad() {\r\n    }\r\n  }\r\n```\r\n使用数据\r\n```\r\n<template lang=\"wxml\">\r\n    <repeat for=\"{{timeConfigData}}\" index=\"index\" item=\"item\" key=\"key\">\r\n    </repeat>\r\n</template>\r\n```\r\n\r\n> 其他方法都与在react中使用相同，通过上面的配置就可以在wepy中使用redux了，详细代码参考[code](https://github.com/leinov/wepy-redux-time-todo)",
            "title": "一个Time TodoList实例了解redux在小程序框架wepy中的使用",
            "last_reply_at": "2018-11-11T05:55:12.657Z",
            "good": false,
            "top": false,
            "reply_count": 4,
            "visit_count": 316,
            "create_at": "2018-10-31T02:46:22.805Z",
            "author": {
                "loginname": "leinov",
                "avatar_url": "https://avatars3.githubusercontent.com/u/6204210?v=4&s=120"
            }
        },
        {
            "id": "5b5e78f5673571454c633cea",
            "author_id": "5b56866ae740336c7bedb345",
            "tab": "share",
            "content": "**koa2实战项目介绍（真全栈）：**\r\n\r\n**Nodejs+koa2实战视频教程**从零开始一步一步让你学会Koa基础以及用用**Koa开发项目**，本教程涉及 用户权限判断 、**验证码** 、分页、多级分类、**ueditor可视化富文本编辑器**、图片上传、**底层DB库封装**、**扩展art-template的核心方法、**ajax改变状态、ajax排序、以及赠送的**Socket.io机器人** 、Socket.io多人聊天室、**Socket.io群聊**、前后端分离 **RESTful API Api**接口、购买域名 服务器、域名备案、**nginx负载均衡**、**域名解析部署nodejs程序**、Nodejs进程管理器pm2模块、Koa操作**mysql数据库**\r\n\r\n**地址：** [Koa2实战视频教程下载地址点我](https://www.itying.com/goods-800.html)\r\n\r\n**2018 Nodejs+Koa2入门实战视频教程百度网盘下载地址（41讲免费基础下载地址）：**\r\n\r\nhttps://pan.baidu.com/s/1KNaA97kGwNhavch5rP_G7w",
            "title": "Nodejs+koa2实战视频教程【87讲】--Koa2+Nodejs+MongoDb打造企业级CMS前后端全栈项目实战视频教程",
            "last_reply_at": "2018-11-11T03:51:54.827Z",
            "good": false,
            "top": false,
            "reply_count": 51,
            "visit_count": 7777,
            "create_at": "2018-07-30T02:33:25.113Z",
            "author": {
                "loginname": "songsunli",
                "avatar_url": "https://avatars1.githubusercontent.com/u/41601667?v=4&s=120"
            }
        },
        {
            "id": "5a559e54afa0a121784a8adc",
            "author_id": "567231087223708362cc6c47",
            "tab": "share",
            "content": "标题虽有点夸大，不过用过nestjs之后，本人是不想在用其他框架了。这里没有想安利大家立马换框架的意思，推荐学习，若要投产，前提是你要足够了解nest。\r\n准确说，nest不是框架，而是一种区别于commonjs的模块规范，或者说是高阶构建工具，它改变了以往团队协同的编码组织结构，使得模块化开发思想真正得以实现，框架目的不是提高开发技术，而是降低模块间耦合风险，隔离了工作区间，带了前所未有的协同开发体验。具体介绍可以看我的git page  链接：[nest介绍](https://yangjdb.github.io/blog/2018/01/08/nest-1/)\r\nnestjs的学习成本较高，对于基础理论，设计模式，原生语法都要有深厚的理解能力，如果想深入了解nest，建议以下步骤：\r\n先看es6的proxy，reflect，symbol  链接：[es6的Reflect](http://es6.ruanyifeng.com/#docs/reflect)\r\n再看typescript的装饰器  链接：[TS装饰器](https://www.tslang.cn/docs/handbook/decorators.html)\r\n再看java的六大设计原则（自行百度）\r\n再看nestjs的开源代码  链接：[nestjs](https://github.com/nestjs/nest)\r\n最后写一个完整的场景覆盖demo（自己动手哦）\r\n你会发现……\r\n前端弱爆了，哈哈哈\r\n开玩笑的，你会爱上nest。",
            "title": "nestjs之后，觉得其他框架脚手架可以立碑了……",
            "last_reply_at": "2018-11-11T03:45:55.046Z",
            "good": false,
            "top": false,
            "reply_count": 23,
            "visit_count": 8981,
            "create_at": "2018-01-10T05:02:12.824Z",
            "author": {
                "loginname": "zbmyyang",
                "avatar_url": "https://avatars1.githubusercontent.com/u/11499299?v=4&s=120"
            }
        },
        {
            "id": "5bc4c826ede204052db80566",
            "author_id": "57b3bfd4d6124db37b1d1333",
            "tab": "ask",
            "content": "## egg.js如何设置启动为https的服务？",
            "title": "求问：egg.js启动的服务如何设置为https",
            "last_reply_at": "2018-11-10T14:27:37.606Z",
            "good": false,
            "top": false,
            "reply_count": 8,
            "visit_count": 426,
            "create_at": "2018-10-15T17:02:30.858Z",
            "author": {
                "loginname": "justbecoder",
                "avatar_url": "https://avatars2.githubusercontent.com/u/21071133?v=4&s=120"
            }
        },
        {
            "id": "5a72c66ace45d440451465c3",
            "author_id": "58400cd63aa1310a5786878f",
            "tab": "share",
            "content": "总共录了18集，课程主要针对 nodejs 初学者，查看下面网址：\r\n\r\nhttps://www.rails365.net/playlists/qing-song-xue-nodejs-ji-chu-pian\r\n\r\n录制视频不易，如果对你有帮助，请多多支持。\r\n\r\n下一套课程计划：Nodejs + express",
            "title": "18集 Node.js 视频入门教程 - 全部免费观看",
            "last_reply_at": "2018-11-10T13:21:07.536Z",
            "good": false,
            "top": false,
            "reply_count": 37,
            "visit_count": 17300,
            "create_at": "2018-02-01T07:48:58.823Z",
            "author": {
                "loginname": "yinsigan",
                "avatar_url": "https://avatars2.githubusercontent.com/u/740643?v=4&s=120"
            }
        },
        {
            "id": "5be673da21d75b74609f603a",
            "author_id": "5bda8a7793f8d64f74b012ae",
            "tab": "share",
            "content": "原文地址：https://www.jianshu.com/p/ab72fe404c8d\r\n\r\n# 前言\r\n前些天刚建了自己的博客：[《极简博客搭建，搭建超级简单又好看》](https://www.jianshu.com/p/527583637f17)\r\n还上了 HTTPS :[《轻松全站 HTTPS，还没用上 https (可申请泛域名证书)的朋友可以操练起来了》](https://www.jianshu.com/p/57e5bb1277ce)\r\n\r\n# 原由\r\n这些天，陆陆续续有朋友问我，这个博客能不能登录啊，有没有用户体系啊。我想也许是我小说写得好看，他们想找地方评论。准备接一个评论组件在里面，方便大家讨论我的文字以及分享自己的看法。\r\n一杯茶的功夫，我就改变了主意，准备自己搭建一个属于自己的社区。在里面汇聚一些自己喜欢的人们。这么大的变故是为什么？因为我想无论怎么接入评论组件，人仍然不在你这。第三方如果恶意收集用户的信息，并技术太弱保护不了这份数据的话，那是在害了我们的用户。且有些组件没事还没弹个广告什么的，着实有点坑。那话不多说，自己建一个吧～\r\n\r\n# 效果预览\r\n前台效果\r\n![前台效果](https://upload-images.jianshu.io/upload_images/14752545-b55d7afc02d072a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\r\n\r\n后台效果\r\n![后台管理界面](https://upload-images.jianshu.io/upload_images/14752545-eb93a1686d7c5993.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\r\n\r\n [要搭论坛，还没有服务器？ 来参加阿里云双 11 底价团，12 号前 99.5/台起！](https://m.aliyun.com/act/team1111/#/share?params=N.9g4CZ2TwSh.n2wswqow)\r\n>![优惠的一小部分](https://upload-images.jianshu.io/upload_images/14752545-847853f809e2593f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\r\n>[查看更多](https://m.aliyun.com/act/team1111/#/share?params=N.9g4CZ2TwSh.n2wswqow)\r\n\r\n# 架构一览\r\n有很多现成的社区解决方案，开源不开源的都有像 wecent、nodebb 什么的。\r\n我挑选了一个可定制化更高，我认为更好看的给大家演示一下。\r\n1. Docker\r\n2. MongoDB/pregresSQL/redis（三个选其一）\r\n3. NodeBB\r\n\r\n# 开始\r\n> ### 1.  安装 Docker (已安装的忽略)\r\n>[CentOS](https://www.jianshu.com/p/3782f86508b5)\r\n[Windows](https://download.docker.com/win/stable/Docker%20for%20Windows%20Installer.exe)\r\n[Mac](https://download.docker.com/mac/stable/Docker.dmg)\r\n\r\n>### 2. 安装 MongoDB/pregresSQL/redis三个选其一\r\n> NODE 的项目就只介绍  MongoDB 的安装吧，如需用 pregresSQL/redis 当作你的数据库，请自己安装，后面只是配置不同\r\n**先创建所需的 docker 网络**\r\n```docker network create mongo-net```\r\n创建了一个名字为`mongo-net`的默认网络\r\n**安装 mongodb**\r\n```docker run --name mongo --restart always --network mongo-net -d mongo --wiredTigerCacheSizeGB 0.25```\r\n> **参数解释(不关心的不用看)**\r\n> **docker run** 表示运行一个容器，可以想像成运行一个程序\r\n>**--name mongo** 给你的程序起个名字，mongo 可以换其它名字\r\n> **--restart always** 表示程序如果死掉就自动重新启动，保证一直提供服务\r\n>**-d** :后台运行你的这个程序\r\n>**mongo** 镜像名\r\n>**--wiredTigerCacheSizeGB 0.25** 设置最大的内存使用为 0.25G\r\n\r\n执行成功后你就完成了数据存储的部分，下面开始安装 NodeBB\r\n\r\n>3. 安装 NodeBB\r\n```docker run --restart always --name forum --network mongo-net -p 4567:4567 -d nodebb/docker```\r\n**参数解释(不关心的不用看)**\r\n**docker run** 表示运行一个容器，可以想像成运行一个程序\r\n> **--restart always** 表示程序如果死掉就自动重新启动，保证一直提供服务\r\n>**--name forum** 给你的程序起个名字，forum 可以换其它名字\r\n>**--network mongo-net** 给这个容器指定一个虚拟网络，不存在则报错，存在则加入这个网络\r\n>**-d** :后台运行你的这个程序\r\n>**nodebb/docker** 镜像名\r\n\r\n执行成功后，你的论坛就已经安装完成了。服务已经启动，你只需要简单配置就能正式上线啦～\r\n\r\n执行成功后，你的论坛就已经安装完成了。服务已经启动，你只需要简单配置就能正式上线啦～\r\n\r\n>4. 配置 NodeBB\r\n在你的浏览器中输入`http://localhost:4567` 进入配置页面\r\n![配置 NodeBB ](https://upload-images.jianshu.io/upload_images/14752545-42e8d3b10f84cf17.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\r\n等一段时间后你会看到这个页面\r\n![安装完成，准备进入你的论坛](https://upload-images.jianshu.io/upload_images/14752545-208bf763b29a568a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\r\n 到这里就全部配置完成了，你可以登录后台设置你的论坛\r\n![用户登录界面](https://upload-images.jianshu.io/upload_images/14752545-c4b6680abc082950.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\r\n可以修改默认语言为中文\r\n![设置语言](https://upload-images.jianshu.io/upload_images/14752545-ab78d0350faef0e7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\r\n![设置成中文，保存后刷新](https://upload-images.jianshu.io/upload_images/14752545-597376d824ab2c51.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\r\n 后台界面\r\n![后台管理界面](https://upload-images.jianshu.io/upload_images/14752545-eb93a1686d7c5993.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\r\n\r\n>5.后台配置\r\n到这里，你已经搭建完成了你的论坛。接下来的工作就是把你论坛配置成你想要的样子，你可以在后台安装一些你需要的插件、主题等，打造一个你自己的论坛。\r\n\r\n# 结语\r\n这个例子的所有操作都是按最简单的方式来写的，且不影响正式的使用。当然一些配置方面的优化，则要看你服务器的具体配置，具体来优化了。后台中有许多有用的插件，比如搜索都可以安装起来，来充实你的论坛。\r\n[论坛不错，可还没服务器？ 来参加阿里云双 11 底价团，12 号前 99.5/台起！](https://m.aliyun.com/act/team1111/#/share?params=N.9g4CZ2TwSh.n2wswqow)",
            "title": "快速搭建论坛，用 NodeBB 搭建自己的社区，汇聚可爱的人们",
            "last_reply_at": "2018-11-10T10:02:48.303Z",
            "good": false,
            "top": false,
            "reply_count": 1,
            "visit_count": 187,
            "create_at": "2018-11-10T05:59:54.592Z",
            "author": {
                "loginname": "gladmo",
                "avatar_url": "https://avatars0.githubusercontent.com/u/18359830?v=4&s=120"
            }
        },
        {
            "id": "5be1370121d75b74609f47b7",
            "author_id": "5b03c9a7000332b81cf821a5",
            "tab": "ask",
            "content": "let a = {\r\n\tname: 'zaki',\r\n\tsay: function() {\r\n\t\tconsole.log(this);\r\n\t\tconsole.log(this.name);\r\n\t}\r\n};\r\n\r\n(function() {\r\n\ta.say(); //可以打印出符合期望的的this信息\r\n\tlet fn = a.say;\r\n\tfn(); // 不能打印出符合期望的this信息\r\n})()",
            "title": "es中的关于this指针丢失问题",
            "last_reply_at": "2018-11-10T08:21:40.783Z",
            "good": false,
            "top": false,
            "reply_count": 7,
            "visit_count": 455,
            "create_at": "2018-11-06T06:38:57.821Z",
            "author": {
                "loginname": "linxiaoziruo",
                "avatar_url": "https://avatars3.githubusercontent.com/u/6881273?v=4&s=120"
            }
        },
        {
            "id": "5be6846821d75b74609f6065",
            "author_id": "57d216e13d3520a5387c2b53",
            "tab": "share",
            "content": "Rt",
            "title": "谁有比较好的restful 的例子。",
            "last_reply_at": "2018-11-10T07:10:32.927Z",
            "good": false,
            "top": false,
            "reply_count": 0,
            "visit_count": 185,
            "create_at": "2018-11-10T07:10:32.927Z",
            "author": {
                "loginname": "a69694510",
                "avatar_url": "https://avatars1.githubusercontent.com/u/20507053?v=4&s=120"
            }
        },
        {
            "id": "5be3a48a646a05745b7b9a47",
            "author_id": "58d140302c8bf2a836456213",
            "tab": "share",
            "content": "**摘要：** 写代码是一门艺术。\r\n\r\n- 原文：[JavaScript 复杂判断的更优雅写法](https://juejin.im/post/5bdfef86e51d453bf8051bf8)\r\n- 作者：Think.\r\n- 公众号：大转转fe\r\n\r\n**[Fundebug](https://www.fundebug.com/)经授权转载，版权归原作者所有。**\r\n\r\n### 前提\r\n\r\n我们编写js代码时经常遇到复杂逻辑判断的情况，通常大家可以用if/else或者switch来实现多个条件判断，但这样会有个问题，随着逻辑复杂度的增加，代码中的if/else/switch会变得越来越臃肿，越来越看不懂，那么如何更优雅的写判断逻辑，本文带你试一下。\r\n\r\n### 举个例子\r\n\r\n先看一段代码\r\n\r\n```javascript\r\n/**\r\n * 按钮点击事件\r\n * @param {number} status 活动状态：1 开团进行中 2 开团失败 3 商品售罄 4 开团成功 5 系统取消\r\n */\r\nconst onButtonClick = (status)=>{\r\n  if(status == 1){\r\n    sendLog('processing')\r\n    jumpTo('IndexPage')\r\n  }else if(status == 2){\r\n    sendLog('fail')\r\n    jumpTo('FailPage')\r\n  }else if(status == 3){\r\n    sendLog('fail')\r\n    jumpTo('FailPage')\r\n  }else if(status == 4){\r\n    sendLog('success')\r\n    jumpTo('SuccessPage')\r\n  }else if(status == 5){\r\n    sendLog('cancel')\r\n    jumpTo('CancelPage')\r\n  }else {\r\n    sendLog('other')\r\n    jumpTo('Index')\r\n  }\r\n}\r\n```\r\n\r\n通过代码可以看到这个按钮的点击逻辑：根据不同活动状态做两件事情，发送日志埋点和跳转到对应页面，大家可以很轻易的提出这段代码的改写方案，switch出场：\r\n\r\n```javascript\r\n/**\r\n * 按钮点击事件\r\n * @param {number} status 活动状态：1 开团进行中 2 开团失败 3 商品售罄 4 开团成功 5 系统取消\r\n */\r\nconst onButtonClick = (status)=>{\r\n  switch (status){\r\n    case 1:\r\n      sendLog('processing')\r\n      jumpTo('IndexPage')\r\n      break\r\n    case 2:\r\n    case 3:\r\n      sendLog('fail')\r\n      jumpTo('FailPage')\r\n      break  \r\n    case 4:\r\n      sendLog('success')\r\n      jumpTo('SuccessPage')\r\n      break\r\n    case 5:\r\n      sendLog('cancel')\r\n      jumpTo('CancelPage')\r\n      break\r\n    default:\r\n      sendLog('other')\r\n      jumpTo('Index')\r\n      break\r\n  }\r\n}\r\n```\r\n\r\n嗯，这样看起来比if/else清晰多了，细心的同学也发现了小技巧，case 2和case 3逻辑一样的时候，可以省去执行语句和break，则case 2的情况自动执行case 3的逻辑。\r\n\r\n这时有同学会说，还有更简单的写法：\r\n\r\n```javascript\r\nconst actions = {\r\n  '1': ['processing','IndexPage'],\r\n  '2': ['fail','FailPage'],\r\n  '3': ['fail','FailPage'],\r\n  '4': ['success','SuccessPage'],\r\n  '5': ['cancel','CancelPage'],\r\n  'default': ['other','Index'],\r\n}\r\n/**\r\n * 按钮点击事件\r\n * @param {number} status 活动状态：1开团进行中 2开团失败 3 商品售罄 4 开团成功 5 系统取消\r\n */\r\nconst onButtonClick = (status)=>{\r\n  let action = actions[status] || actions['default'],\r\n      logName = action[0],\r\n      pageName = action[1]\r\n  sendLog(logName)\r\n  jumpTo(pageName)\r\n}\r\n```\r\n\r\n上面代码确实看起来更清爽了，这种方法的聪明之处在于：将判断条件作为对象的属性名，将处理逻辑作为对象的属性值，在按钮点击的时候，通过对象属性查找的方式来进行逻辑判断，这种写法特别适合一元条件判断的情况。\r\n\r\n是不是还有其他写法呢？有的：\r\n\r\n```javascript\r\nconst actions = new Map([\r\n  [1, ['processing','IndexPage']],\r\n  [2, ['fail','FailPage']],\r\n  [3, ['fail','FailPage']],\r\n  [4, ['success','SuccessPage']],\r\n  [5, ['cancel','CancelPage']],\r\n  ['default', ['other','Index']]\r\n])\r\n/**\r\n * 按钮点击事件\r\n * @param {number} status 活动状态：1 开团进行中 2 开团失败 3 商品售罄 4 开团成功 5 系统取消\r\n */\r\nconst onButtonClick = (status)=>{\r\n  let action = actions.get(status) || actions.get('default')\r\n  sendLog(action[0])\r\n  jumpTo(action[1])\r\n}\r\n```\r\n\r\n这样写用到了es6里的Map对象，是不是更爽了？Map对象和Object对象有什么区别呢？\r\n\r\n1. 一个对象通常都有自己的原型，所以一个对象总有一个\"prototype\"键。\r\n2. 一个对象的键只能是字符串或者Symbols，但一个Map的键可以是任意值。\r\n3. 你可以通过size属性很容易地得到一个Map的键值对个数，而对象的键值对个数只能手动确认。\r\n\r\n我们需要把问题升级一下，以前按钮点击时候只需要判断status，现在还需要判断用户的身份：\r\n\r\n```javascript\r\n/**\r\n * 按钮点击事件\r\n * @param {number} status 活动状态：1开团进行中 2开团失败 3 开团成功 4 商品售罄 5 有库存未开团\r\n * @param {string} identity 身份标识：guest客态 master主态\r\n */\r\nconst onButtonClick = (status,identity)=>{\r\n  if(identity == 'guest'){\r\n    if(status == 1){\r\n      //do sth\r\n    }else if(status == 2){\r\n      //do sth\r\n    }else if(status == 3){\r\n      //do sth\r\n    }else if(status == 4){\r\n      //do sth\r\n    }else if(status == 5){\r\n      //do sth\r\n    }else {\r\n      //do sth\r\n    }\r\n  }else if(identity == 'master') {\r\n    if(status == 1){\r\n      //do sth\r\n    }else if(status == 2){\r\n      //do sth\r\n    }else if(status == 3){\r\n      //do sth\r\n    }else if(status == 4){\r\n      //do sth\r\n    }else if(status == 5){\r\n      //do sth\r\n    }else {\r\n      //do sth\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n原谅我不写每个判断里的具体逻辑了，因为代码太冗长了。\r\n\r\n原谅我又用了if/else，因为我看到很多人依然在用if/else写这种大段的逻辑判断。\r\n\r\n从上面的例子我们可以看到，当你的逻辑升级为二元判断时，你的判断量会加倍，你的代码量也会加倍，这时怎么写更清爽呢？\r\n\r\n```javascript\r\nconst actions = new Map([\r\n  ['guest_1', ()=>{/*do sth*/}],\r\n  ['guest_2', ()=>{/*do sth*/}],\r\n  ['guest_3', ()=>{/*do sth*/}],\r\n  ['guest_4', ()=>{/*do sth*/}],\r\n  ['guest_5', ()=>{/*do sth*/}],\r\n  ['master_1', ()=>{/*do sth*/}],\r\n  ['master_2', ()=>{/*do sth*/}],\r\n  ['master_3', ()=>{/*do sth*/}],\r\n  ['master_4', ()=>{/*do sth*/}],\r\n  ['master_5', ()=>{/*do sth*/}],\r\n  ['default', ()=>{/*do sth*/}],\r\n])\r\n\r\n/**javascript\r\n * 按钮点击事件\r\n * @param {string} identity 身份标识：guest客态 master主态\r\n * @param {number} status 活动状态：1 开团进行中 2 开团失败 3 开团成功 4 商品售罄 5 有库存未开团\r\n */\r\nconst onButtonClick = (identity,status)=>{\r\n  let action = actions.get(`${identity}_${status}`) || actions.get('default')\r\n  action.call(this)\r\n}\r\n```\r\n\r\n上述代码核心逻辑是：把两个条件拼接成字符串，并通过以条件拼接字符串作为键，以处理函数作为值的Map对象进行查找并执行，这种写法在多元条件判断时候尤其好用。\r\n\r\n当然上述代码如果用Object对象来实现也是类似的：\r\n\r\n```javascript\r\nconst actions = {\r\n  'guest_1':()=>{/*do sth*/},\r\n  'guest_2':()=>{/*do sth*/},\r\n  //....\r\n}\r\n\r\nconst onButtonClick = (identity,status)=>{\r\n  let action = actions[`${identity}_${status}`] || actions['default']\r\n  action.call(this)\r\n}\r\n```\r\n\r\n如果有些同学觉得把查询条件拼成字符串有点别扭，那还有一种方案，就是用Map对象，以Object对象作为key：\r\n\r\n```javascript\r\nconst actions = new Map([\r\n  [{identity:'guest',status:1},()=>{/*do sth*/}],\r\n  [{identity:'guest',status:2},()=>{/*do sth*/}],\r\n  //...\r\n])\r\n\r\nconst onButtonClick = (identity,status)=>{\r\n  let action = [...actions].filter(([key,value])=>(key.identity == identity && key.status == status))\r\n  action.forEach(([key,value])=>value.call(this))\r\n}\r\n```\r\n\r\n是不是又高级了一点点？\r\n\r\n这里也看出来Map与Object的区别，Map可以用任何类型的数据作为key。\r\n\r\n我们现在再将难度升级一点点，假如guest情况下，status1-4的处理逻辑都一样怎么办，最差的情况是这样：\r\n\r\n```javascript\r\nconst actions = new Map([\r\n  [{identity:'guest',status:1},()=>{/* functionA */}],\r\n  [{identity:'guest',status:2},()=>{/* functionA */}],\r\n  [{identity:'guest',status:3},()=>{/* functionA */}],\r\n  [{identity:'guest',status:4},()=>{/* functionA */}],\r\n  [{identity:'guest',status:5},()=>{/* functionB */}],\r\n  //...\r\n])\r\n```\r\n\r\n好一点的写法是将处理逻辑函数进行缓存：\r\n\r\n```javascript\r\nconst actions = ()=>{\r\n  const functionA = ()=>{/*do sth*/}\r\n  const functionB = ()=>{/*do sth*/}\r\n  return new Map([\r\n    [{identity:'guest',status:1},functionA],\r\n    [{identity:'guest',status:2},functionA],\r\n    [{identity:'guest',status:3},functionA],\r\n    [{identity:'guest',status:4},functionA],\r\n    [{identity:'guest',status:5},functionB],\r\n    //...\r\n  ])\r\n}\r\n\r\nconst onButtonClick = (identity,status)=>{\r\n  let action = [...actions()].filter(([key,value])=>(key.identity == identity && key.status == status))\r\n  action.forEach(([key,value])=>value.call(this))\r\n}\r\n```\r\n\r\n这样写已经能满足日常需求了，但认真一点讲，上面重写了4次functionA还是有点不爽，假如判断条件变得特别复杂，比如identity有3种状态，status有10种状态，那你需要定义30条处理逻辑，而往往这些逻辑里面很多都是相同的，这似乎也是笔者不想接受的，那可以这样实现:\r\n\r\n```javascript\r\nconst actions = ()=>{\r\n  const functionA = ()=>{/*do sth*/}\r\n  const functionB = ()=>{/*do sth*/}\r\n  return new Map([\r\n    [/^guest_[1-4]$/,functionA],\r\n    [/^guest_5$/,functionB],\r\n    //...\r\n  ])\r\n}\r\n\r\nconst onButtonClick = (identity,status)=>{\r\n  let action = [...actions()].filter(([key,value])=>(key.test(`${identity}_${status}`)))\r\n  action.forEach(([key,value])=>value.call(this))\r\n}\r\n```\r\n\r\n这里Map的优势更加凸显，可以用正则类型作为key了，这样就有了无限可能，假如需求变成，凡是guest情况都要发送一个日志埋点，不同status情况也需要单独的逻辑处理，那我们可以这样写:\r\n\r\n```javascript\r\nconst actions = ()=>{\r\n  const functionA = ()=>{/*do sth*/}\r\n  const functionB = ()=>{/*do sth*/}\r\n  const functionC = ()=>{/*send log*/}\r\n  return new Map([\r\n    [/^guest_[1-4]$/,functionA],\r\n    [/^guest_5$/,functionB],\r\n    [/^guest_.*$/,functionC],\r\n    //...\r\n  ])\r\n}\r\n\r\nconst onButtonClick = (identity,status)=>{\r\n  let action = [...actions()].filter(([key,value])=>(key.test(`${identity}_${status}`)))\r\n  action.forEach(([key,value])=>value.call(this))\r\n}\r\n```\r\n\r\n也就是说利用数组循环的特性，符合正则条件的逻辑都会被执行，那就可以同时执行公共逻辑和单独逻辑，因为正则的存在，你可以打开想象力解锁更多的玩法，本文就不赘述了。\r\n\r\n### 总结\r\n\r\n本文已经教你了8种逻辑判断写法，包括：\r\n\r\n1. if/else\r\n2. switch\r\n3. 一元判断时：存到Object里\r\n4. 一元判断时：存到Map里\r\n5. 多元判断时：将condition拼接成字符串存到Object里\r\n6. 多元判断时：将condition拼接成字符串存到Map里\r\n7. 多元判断时：将condition存为Object存到Map里\r\n8. 多元判断时：将condition写作正则存到Map里\r\n\r\n至此，本文也将告一段落，愿你未来的人生里，不只是有if/else/switch。\r\n\r\n### 关于Fundebug\r\n\r\n[Fundebug](https://www.fundebug.com/)专注于JavaScript、微信小程序、微信小游戏、支付宝小程序、React Native、Node.js和Java实时BUG监控。 自从2016年双十一正式上线，Fundebug累计处理了7亿+错误事件，得到了Google、360、金山软件、百姓网等众多知名用户的认可。欢迎免费试用！\r\n\r\n![](https://static.fundebug.cn/wechat_slogan.png)",
            "title": "JavaScript复杂判断的更优雅写法",
            "last_reply_at": "2018-11-10T04:11:10.476Z",
            "good": false,
            "top": false,
            "reply_count": 7,
            "visit_count": 555,
            "create_at": "2018-11-08T02:50:50.115Z",
            "author": {
                "loginname": "Fundebug",
                "avatar_url": "https://avatars2.githubusercontent.com/u/26496557?v=4&s=120"
            }
        },
        {
            "id": "5b972808ce9d14c2254df8b0",
            "author_id": "56ea011fa70420bd420d0001",
            "tab": "share",
            "content": "楼主自己也是才踩 react 的路。。之前偷懒用了 vuejs 就不思上进了...无赖美帝都是 react 占据了90个点的江山.*\r\n**一直觉得学习，选择好的学习资料和学习的顺序很重要.. 对了，路子顺..挫折感小. ** 希望自己的学习顺序，能给别人带来帮助.\r\n群主弄了个 QQ 技术交流群: 371932256 ，方便讨论我的 cnodejs 的 react 版本的项目...一起进步...也欢迎高手加入...哈哈...\r\n\r\n1. 掌握 react 的基本概念\r\n   1.1 看视频课程：https://time.geekbang.org/course/intro/100 （非推广…只是个人是个很热心的妹砸） 01 ~10\r\n  1.2 边看然后边刷官方的 Main Concepts 部分的文档https://reactjs.org/docs/hello-world.html 做好第一步和第二步后，对 react 有基本的概念了…\r\n \r\n 2. 学习 redux/react-redux\r\n  2.1 看ruanyifeng 的 redux/react-redux 教程… 看教程第一二篇的时候，会有个基本的概念呢…\r\n  2.2  然后返回去看 11~ 15， 视频讲解的 redux、react 课程\r\n当然你在刷课课程中，也会不时的去看看官方文档看看些细节. flux 等概念\r\n 2.3  在上述步骤（3.1 ~3.2 ） 中，你会做 Counter 的例子，了解 redux 的基本玩法… 也会把 Counter的例子改成结合 react-redux 类型的; \r\n如果这两个例子完成了…可以试试这个视频教程…\r\n2.4 完成一个小demo: https://www.youtube.com/watch?v=93p3LxR9xfM&t=1168s 这部分想必，对新手会绕一段时间…特别是 redux 这部分如果你没进去看过源码…有时候会被 API 绕晕…觉得 API 多\r\n这边是楼主写的 redux 阅读笔记: https://github.com/pandoracat/learn-react/blob/master/Notes/Redux/includes/markdown/ReduxSourceCode.md\r\n\r\n3. 完成学习 react基本概念.. redux/react-redux 基本用法后...（一定要试着敲每个课程的代码哟，扎扎实实走过来的，你内心才踏实)\r\n可以直接去 react-router 官网看看 demo, 边用用demo, 了解文档，了解用法. 如果有朋友觉得英文文档看起来吃力，可以看看这个 https://www.jianshu.com/p/1781bc1dd938#24-history\r\n4. 学习完这些后，咱看看 react 项目，代码咋拆分..咋组织\r\n课程22~25 ： https://time.geekbang.org/course/detail/100-11278 \r\n\r\n5. 这些都过了,下面看 react 怎么测试。关于 react 测试： 强行硬广一波自己的笔记：https://github.com/pandoracat/frontend-testing ，我记录了自己的 javascript 测试的学习路程...\r\n6. 上面这些你都做了...咱们再把视频教程撸撸... 再次提升下自己的理解..\r\n7. 最后，react cnode , 新手练手都用它 😎..看看 它的 api, 咱们 ready go 写个项目试试.\r\n这边是我正在写的 https://github.com/pandoracat/react-cnode 欢迎瞧瞧..我会写自己的 readme, 方便你照着模仿一个...\r\n弱弱的觉得自己设计的风格还不错（偷笑,我是一个审美超级弱的前端妹纸）\r\n怎么开始这个用 cnodejs.org 做 api 服务器的练手项目呢?请点击：https://github.com/pandoracat/react-cnode\r\n\r\n群主弄了个 QQ 技术交流群: 371932256 ，方便讨论我的 cnodejs 的 react 版本的项目...一起进步...也欢迎高手加入...哈哈...",
            "title": "分享自己的 react 学习路径",
            "last_reply_at": "2018-11-09T15:50:31.974Z",
            "good": false,
            "top": false,
            "reply_count": 21,
            "visit_count": 1693,
            "create_at": "2018-09-11T02:27:20.076Z",
            "author": {
                "loginname": "alicePan",
                "avatar_url": "https://avatars2.githubusercontent.com/u/9105986?v=4&s=120"
            }
        },
        {
            "id": "5231a630101e574521e45ef8",
            "author_id": "5110f2bedf9e9fcc584e4677",
            "tab": "share",
            "content": "require 用来加载代码，而 exports 和 module.exports 则用来导出代码。但很多新手可能会迷惑于 exports 和 module.exports 的区别，为了更好的理解 exports 和 module.exports 的关系，我们先来巩固下 js 的基础。示例：\r\n\r\n**test.js**\r\n\r\nvar a = {name: 1};\r\nvar b = a;\r\n\r\nconsole.log(a);\r\nconsole.log(b);\r\n\r\nb.name = 2;\r\nconsole.log(a);\r\nconsole.log(b);\r\n\r\nvar b = {name: 3};\r\nconsole.log(a);\r\nconsole.log(b);\r\n\r\n运行 test.js 结果为：\r\n\r\n{ name: 1 }\r\n{ name: 1 }\r\n{ name: 2 }\r\n{ name: 2 }\r\n{ name: 2 }\r\n{ name: 3 }\r\n\r\n**解释**：a 是一个对象，b 是对 a 的引用，即 a 和 b 指向同一块内存，所以前两个输出一样。当对 b 作修改时，即 a 和 b 指向同一块内存地址的内容发生了改变，所以 a 也会体现出来，所以第三四个输出一样。当 b 被覆盖时，b 指向了一块新的内存，a 还是指向原来的内存，所以最后两个输出不一样。\r\n\r\n明白了上述例子后，我们只需知道三点就知道 exports 和 module.exports 的区别了：\r\n\r\n1. module.exports 初始值为一个空对象 {}\r\n2. exports 是指向的 module.exports 的引用\r\n3. require() 返回的是 module.exports 而不是 exports\r\n\r\n现在我们来看 Node.js 官方文档的截图:\r\n![屏幕快照 2016-09-29 上午11.59.44.png](//static.cnodejs.org/FjN9jHWiy-yuUtghTUlRgB_0cgUC)\r\n我们经常看到这样的写法：\r\n```\r\nexports = module.exports = somethings\r\n```\r\n上面的代码等价于:\r\n```\r\nmodule.exports = somethings\r\nexports = module.exports\r\n```\r\n原理很简单，即 module.exports 指向新的对象时，exports 断开了与 module.exports 的引用，那么通过 exports = module.exports 让 exports 重新指向 module.exports 即可。",
            "title": "exports 和 module.exports 的区别",
            "last_reply_at": "2018-11-09T11:15:38.918Z",
            "good": true,
            "top": false,
            "reply_count": 109,
            "visit_count": 263868,
            "create_at": "2013-09-12T11:32:00.741Z",
            "author": {
                "loginname": "nswbmw",
                "avatar_url": "https://avatars0.githubusercontent.com/u/4279697?v=4&s=120"
            }
        },
        {
            "id": "5be50091646a05745b7ba10a",
            "author_id": "5be13241646a05745b7b8d26",
            "tab": "ask",
            "content": "最近在看node in aciton 照着书来当用到标准库模组就会无响应，使用npm install 把标准库模组安装到目录下也是一样。\r\n不使用标准库的模组的文件就可以正常执行，搜了一圈并没有看到类似问题，菜鸟初提问欢迎批评",
            "title": "node 执行文件后无响应",
            "last_reply_at": "2018-11-09T10:46:04.900Z",
            "good": false,
            "top": false,
            "reply_count": 2,
            "visit_count": 181,
            "create_at": "2018-11-09T03:35:45.610Z",
            "author": {
                "loginname": "StoneCX",
                "avatar_url": "https://avatars0.githubusercontent.com/u/7904384?v=4&s=120"
            }
        },
        {
            "id": "5be4f94121d75b74609f5ad8",
            "author_id": "5683f44959ec59521f2f1761",
            "tab": "ask",
            "content": "![捕获.JPG](//static.cnodejs.org/FsqsvOu5mz4uHo_Af3paIAAytQHX)\r\n\r\n---\r\n\r\n而且在postman中第一次请求耗时是500ms左右？\r\n![捕获2.JPG](//static.cnodejs.org/Fq30Z-sNQP_h4_JnC2EKC9mx643U)\r\n\r\n\r\n---\r\n\r\n是因为TCP链接建立的时间么？后面有keepAlive所以时间减少了？",
            "title": "测试koa的并发能力，为什么都是从1000ms开始缓慢降下来的？",
            "last_reply_at": "2018-11-09T10:37:49.343Z",
            "good": false,
            "top": false,
            "reply_count": 3,
            "visit_count": 300,
            "create_at": "2018-11-09T03:04:33.451Z",
            "author": {
                "loginname": "meiwhu",
                "avatar_url": "https://avatars0.githubusercontent.com/u/15714433?v=4&s=120"
            }
        },
        {
            "id": "5a049ced88c853c52fd56804",
            "author_id": "57d216e13d3520a5387c2b53",
            "tab": "ask",
            "content": "我刚才试了试，就连最新版本的qq浏览器 9.6.5极速版都不支持，更别提兼容模式了，还有ie好多版本更不支持，你们在工作中，会实际用es7 es8的写法吗\n\n来自酷炫的 [CNodeMD](https://github.com/TakWolf/CNode-Material-Design)",
            "title": "大家工作中真的会用asnyc await这种es7的写法吗",
            "last_reply_at": "2018-11-09T10:00:07.692Z",
            "good": false,
            "top": false,
            "reply_count": 18,
            "visit_count": 2054,
            "create_at": "2017-11-09T18:22:37.015Z",
            "author": {
                "loginname": "a69694510",
                "avatar_url": "https://avatars1.githubusercontent.com/u/20507053?v=4&s=120"
            }
        },
        {
            "id": "5bdd1af6646a05745b7b7bf3",
            "author_id": "59aa89ea9e95202d08c91ed3",
            "tab": "ask",
            "content": "```\r\n(async () => {\r\n\tconst mobileUrl = `http://mobile.open.163.com/movie/MCL8DCPJT/getMoviesForAndroid.htm`;\r\n\tconst resp = await fetch(mobileUrl, {'mode': 'no-cors'});\r\n\tconst data = await resp.json();\r\n\tconsole.log(data);\r\n})();\r\n```\r\n我将下载的内容手动用JSON.parse解析却OK",
            "title": "为什么fetch后~报JSON解析错误？",
            "last_reply_at": "2018-11-09T09:24:32.501Z",
            "good": false,
            "top": false,
            "reply_count": 3,
            "visit_count": 457,
            "create_at": "2018-11-03T03:50:14.968Z",
            "author": {
                "loginname": "xinggsf",
                "avatar_url": "https://avatars3.githubusercontent.com/u/13033798?v=4&s=120"
            }
        },
        {
            "id": "5be2b2c121d75b74609f50d8",
            "author_id": "593129689a99de3b489289c5",
            "tab": "ask",
            "content": "登入成功在response.header中返回set-cookie,前端如何获取这个cookie值\r\n前端的同学说获取不到请求头里的值",
            "title": "登入成功在response.header中返回set-cookie,前端如何获取这个cookie值",
            "last_reply_at": "2018-11-09T09:12:09.191Z",
            "good": false,
            "top": false,
            "reply_count": 9,
            "visit_count": 308,
            "create_at": "2018-11-07T09:39:13.532Z",
            "author": {
                "loginname": "qqxwbtt",
                "avatar_url": "https://avatars3.githubusercontent.com/u/28970770?v=4&s=120"
            }
        },
        {
            "id": "51fc8bd944e76d216ab64939",
            "author_id": "50ab99f8637ffa41554d1fa9",
            "tab": "share",
            "content": "转载自：[http://blog.csdn.net/kidx_/article/details/9709387](http://blog.csdn.net/kidx_/article/details/9709387)\r\n\r\nGM : GraphicsMagick for node.js\r\n首先得安装 GraphicsMagick 或者 ImageMagick。\r\n然后执行：\r\n     $ sudo npm install gm\r\n\r\n我安装的是ImageMagick，在ubuntu系统下快速安装：\r\n     $ sudo apt-get install imagemagick\r\n\r\nHOW TO USE\r\nGM 文档：[http://aheckmann.github.io/gm/docs.html](http://aheckmann.github.io/gm/docs.html)\r\n使用ImageMagick\r\n    var imageMagick = gm.subClass({ imageMagick: true });\r\n然后就像文档中使用gm那样使用ImageMagick即可（举个例子）\r\n    imageMagick(\"img.png\").resize(300, 100).autoOrient().write('/path', callback);\r\n\r\nExample (nodejs + Express)\r\n\r\n    var gm = require('gm')\r\n    ,  fs = require('fs')\r\n    ,\timageMagick = gm.subClass({ imageMagick : true });\r\n    exports.imgUpload = function(req, res) {\r\n    \tres.header('Content-Type', 'text/plain');\r\n      var path = req.files.img.path;\t//获取用户上传过来的文件的当前路径\r\n      var sz = req.files.img.size;\r\n      if (sz > 2*1024*1024) {\r\n        fs.unlink(path, function() {\t//fs.unlink 删除用户上传的文件\r\n          res.end('1');\r\n        });\r\n      } else if (req.files.img.type.split('/')[0] != 'image') {\r\n        fs.unlink(path, function() {\r\n          res.end('2');\r\n        });\r\n      } else {\r\n        imageMagick(path)\r\n        .resize(150, 150, '!') //加('!')强行把图片缩放成对应尺寸150*150！\r\n        .autoOrient()\r\n        .write('public/images/user/'+req.files.img.name, function(err){\r\n          if (err) {\r\n            console.log(err);\r\n            res.end();\r\n          }\r\n          fs.unlink(path, function() {\r\n            return res.end('3');\r\n          });\r\n        });\r\n      }\r\n    };\r\n\r\n上面只是index.js文件的部分核心代码\r\n[点击去下载完整Example](http://pan.baidu.com/share/link?shareid=2913111267&uk=2552401515)\r\n\r\n示例运行截图：\r\n![alt example](http://img.blog.csdn.net/20130802161424593?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQva2lkeF8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\r\n\r\n可以查看 public/images/user/ 里面的图片，验证你上传的图片是否被缩放了。\r\n\r\n同理可对图片进行裁切：\r\ngm(\"img.png\").crop(width, height, x, y)\r\n\r\n详情看gm的文档http://aheckmann.github.io/gm/docs.html\r\n\r\n",
            "title": "Node.js 对图片进行裁切、缩放 (gm)",
            "last_reply_at": "2018-11-09T06:33:11.846Z",
            "good": true,
            "top": false,
            "reply_count": 55,
            "visit_count": 69436,
            "create_at": "2013-08-03T04:49:29.434Z",
            "author": {
                "loginname": "kimady",
                "avatar_url": "//gravatar.com/avatar/2c63b57d3c76ccaed06fcc34ba0e8d33?size=48"
            }
        },
        {
            "id": "5be41bfa21d75b74609f57dd",
            "author_id": "580c1addc3fead57507172a9",
            "tab": "ask",
            "content": "正在写一个koa项目 需要使用redis存储数据 遇到的问题是redis存储是异步的 不能保证执行顺序 有人遇到类似问题嘛？是怎么解决的呢。。。",
            "title": "koa项目中使用redis如何控制执行顺序",
            "last_reply_at": "2018-11-09T04:10:40.864Z",
            "good": false,
            "top": false,
            "reply_count": 4,
            "visit_count": 228,
            "create_at": "2018-11-08T11:20:26.643Z",
            "author": {
                "loginname": "jowang2016",
                "avatar_url": "https://avatars1.githubusercontent.com/u/18169317?v=4&s=120"
            }
        },
        {
            "id": "516e0ab46d382773067a5473",
            "author_id": "50cbf5fb637ffa41556d22f2",
            "content": " 我要将用户查询的结果信息保存到csv或者execl（由于没有找到合适的execl库，所以采用csv库保存）中， 结果用execl打开csv文件发现乱码，通过google找到iconv-lite，可结果还是不行 。代码如下：\r\nfs.open(config.UP_PATH+'/csv/'+troopId+year+month+'.csv','a');\r\n    var csvData = '\"序号\",\"检查人\",\"检查日期\",\"省\",\"城市\",\"系统\",\"售点\",\"地址\",\"门店类型\",'+shopnames;\r\n    var b = Iconv.encode(csvData,'GBK');\r\n    csv().from.string(b).to(config.UP_PATH+\"/csv/\"+troopId+year+month+'.csv');\r\n\r\n\r\nshopnames：是一个中文字符串变量",
            "title": "怎么解决数据保存到csv文件乱码问题",
            "last_reply_at": "2018-11-09T03:56:42.719Z",
            "good": false,
            "top": false,
            "reply_count": 24,
            "visit_count": 46771,
            "create_at": "2013-04-17T02:36:36.681Z",
            "author": {
                "loginname": "zjshop",
                "avatar_url": "//gravatar.com/avatar/9515c08503d6ee8bf1612e9bd8273f22?size=48"
            }
        },
        {
            "id": "5be4f36c21d75b74609f5a73",
            "author_id": "5639e5516d966e1a39996b1a",
            "tab": "share",
            "content": "![webpack-react-multi-page](http://www.h5cool.com/webpack-react3.png)\r\n \r\n\r\n## 仓库\r\nhttps://github.com/leinov/webpack-react-multi-page\r\n\r\n## 特性\r\n* 👩‍👩‍👧‍👧 支持多页面同时热加载开发\r\n* 📇 自动识别新创建页面\r\n* 📝 每个页面生成个性化信息\r\n* 🚻 分类打包\r\n* 🔗 灵活扩展\r\n\r\n\r\n## 安装&使用\r\n\r\n```\r\n// clone\r\ngit clone git@github.com:leinov/webpack-react-multi-page.git\r\n\r\n// 安装依赖包\r\nnpm install\r\n\r\n// 开发\r\nnpm run dev\r\n\r\n// 编译打包\r\nnpm run build\r\n\r\n// 启动生产页面\r\nnpm start\r\n```\r\n新创建页面在src下添加文件夹并创建```pageinfo.json``` 然后```npm run dev``` 即可\r\n```\r\n|-- src\r\n    |-- index/\r\n    |-- page2/\r\n        |-- index.js\r\n        |-- pageinfo.json\r\n```\r\n## 项目架构\r\n#### 技术使用\r\n* ```react16```\r\n* ```webpack4```\r\n    * ```html-webpack-plugin 生成html文件```\r\n    * ```mini-css-extract-plugin css分离打包```\r\n    * ```uglifyjs-webpack-plugin js压缩```\r\n    * ```optimize-css-assets-webpack-plugin css压缩```\r\n* ```es6```\r\n* ```babel```\r\n* ```node ```\r\n    * ```opn 打开浏览器```\r\n    * ```compression 开启gzip压缩```\r\n    * ```express```\r\n    * ```fs```\r\n* ```git```\r\n\r\n#### 目录结构\r\n```\r\n|-- webpack-react-multi-pages //项目\r\n    |-- dist //编译生产目录\r\n        |-- index\r\n            |-- index.css\r\n            |-- index.js\r\n        |-- about\r\n            |-- about.css\r\n            |-- about.js\r\n        |-- images\r\n        |-- index.html\r\n        |-- about.html\r\n    |-- node_modules //node包\r\n    |-- src //开发目录\r\n        |-- index //index页面打包入口\r\n            |-- images/\r\n            |-- js\r\n                |-- app.js// 业务js\r\n            |-- index.sass\r\n            |-- index.js //页面js入口\r\n        |-- about //about页面打包入口\r\n            |-- images/\r\n                |--js\r\n                    |-- app.js// 业务js\r\n            |-- about.sass\r\n            |-- about.js //页面js入口\r\n        |-- template.html // html模板\r\n        |-- style.sass //公共sass\r\n    |-- webpackConfig //在webpack中使用\r\n        |-- getEntry.js //获取入口\r\n        |-- getFilepath.js //src下需要打包页面文件夹\r\n        |-- htmlconfig.js //每个页面html注入数据\r\n    |-- package.json\r\n    |-- .gitignore\r\n    |-- webpack.config.js //webpack配置文件\r\n    |-- www.js //生产启动程序\r\n```\r\n\r\n## [完整wiki](http://www.leinov.com/webpack-react-multi-page/)",
            "title": "node+webpack+react多页面开发终极架构",
            "last_reply_at": "2018-11-09T02:39:40.798Z",
            "good": false,
            "top": false,
            "reply_count": 0,
            "visit_count": 215,
            "create_at": "2018-11-09T02:39:40.798Z",
            "author": {
                "loginname": "leinov",
                "avatar_url": "https://avatars3.githubusercontent.com/u/6204210?v=4&s=120"
            }
        },
        {
            "id": "5be23052646a05745b7b90c0",
            "author_id": "545870576537f4d52c414eb6",
            "tab": "ask",
            "content": "如题，我的网站采用 七牛云 存储 实现图片托管，近期七牛云更改业务规范，要求必须 使用备案域名 更新 存储配置 ，否则停止为新上传的图片提供cdn服务\r\n大家如何应对？ 申请备案好特么麻烦",
            "title": "七牛云 要求必须配置备案后的域名 才能继续使用，大家如何应对？ 本论坛也是七牛云吧",
            "last_reply_at": "2018-11-09T02:22:16.701Z",
            "good": false,
            "top": false,
            "reply_count": 6,
            "visit_count": 371,
            "create_at": "2018-11-07T00:22:42.869Z",
            "author": {
                "loginname": "pangguoming",
                "avatar_url": "https://avatars1.githubusercontent.com/u/7269202?v=4&s=120"
            }
        },
        {
            "id": "5b3748c457137f22415c5143",
            "author_id": "5b37469f57137f22415c5140",
            "tab": "share",
            "content": "当你用了Koa以后，你肯定不会再用express，因为Koa太优秀了!\r\n\r\n**2018 Nodejs+Koa2入门实战视频教程百度网盘下载地址：**\r\n\r\n\r\n[](https://pan.baidu.com/s/1KNaA97kGwNhavch5rP_G7w)https://pan.baidu.com/s/1KNaA97kGwNhavch5rP_G7w\r\n\r\n\r\n\r\nNodejs Koa交流群：319732955   想和大神交流的加下群",
            "title": "2018 Nodejs+Koa2入门实战视频教程【共41集】-欢迎拍砖免费分享【网盘直接下载】",
            "last_reply_at": "2018-11-09T02:08:14.720Z",
            "good": false,
            "top": false,
            "reply_count": 56,
            "visit_count": 9520,
            "create_at": "2018-06-30T09:09:24.209Z",
            "author": {
                "loginname": "koa666",
                "avatar_url": "https://avatars3.githubusercontent.com/u/37576865?v=4&s=120"
            }
        },
        {
            "id": "5be4481b646a05745b7b9e9d",
            "author_id": "5a924b1e71327bb413bbfe26",
            "tab": "ask",
            "content": "谁碰过这个问题？\r\n\r\n如果是9666 端口就没问题， 改成80端口 就访问不了，不知道为什么， 重启nginx 也没报错。\r\n```\r\nserver {\r\n      listen      9666;\r\n      server_name  test.test.com;\r\n     location / {\r\n        root   /www;\r\n        index index.html;\r\n      }\r\n}\r\n```",
            "title": "nginx配置80端口不生效",
            "last_reply_at": "2018-11-09T01:58:49.897Z",
            "good": false,
            "top": false,
            "reply_count": 5,
            "visit_count": 176,
            "create_at": "2018-11-08T14:28:43.448Z",
            "author": {
                "loginname": "six-666",
                "avatar_url": "https://avatars0.githubusercontent.com/u/36760287?v=4&s=120"
            }
        }
    ]
